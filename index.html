<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Castle War Prototype</title>
  <style>
    body {
      margin: 0;
      background: #ade16a;
      font-family: sans-serif;
      overflow: hidden;
    }
    #game {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: url("bg.jpg") center/cover no-repeat;
      padding-bottom: 110px; /* bar(90) + 20px breathing room */
      box-sizing: border-box;
    }
    .object {
      position: absolute;
      transform: translate(-50%, -50%);
      cursor: pointer;
      text-align: center;
    }
    .object span {
      display: block;
      font-size: 10px;
      margin-top: 2px;
      color: white;
      text-shadow: 1px 1px 2px black;
    }
    .castle {
      width: 64px;
    }
    .mine {
      width: 48px;
    }
    .center {
      width: 72px;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
    }
    #troop-panel {
      position: fixed;         /* detached from playfield */
      bottom: 0;
      left: 0;
      right: 0;
      height: 90px;            /* thinner bar */
      background: rgba(0,0,0,0.9); /* solid dark background */
      padding: 10px 16px;      /* inner spacing */
      color: #fff;
      font-size: 14px;
      display: flex;
      justify-content: space-around;
      align-items: center;
      gap: 20px;
      z-index: 40;             /* above map, below toasts */
      border-top: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(2px);
    }
    .troop-btn {
      background: #3a8;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    .local-player {
      border: 2px solid yellow;
      box-shadow: 0 0 10px yellow;
    }
    .army-icon {
      width: 24px;
      position: absolute;
      transition: all linear;
    }
    .mine.owned {
      /* visual marker for owned farms; color set inline via style */
      outline: 2px solid;
      outline-offset: 2px;
    }
    .castle.owned {
      outline: 2px solid;
      outline-offset: 2px;
    }
    .center.owned {
      outline: 2px solid;
      outline-offset: 2px;
    }
    .army-icon.bubble {
      border: 2px solid;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
      background: rgba(255,255,255,0.2);
    }
    .army-glyph {
      width: 14px;
      height: 14px;
      vertical-align: -2px;
      margin-right: 3px;
      image-rendering: pixelated;
    }
    #sidebar {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 20;
      width: 240px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border-radius: 8px;
      overflow: hidden;
      font-size: 14px;
    }
    #sidebar summary {
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(0,0,0,0.7);
    }
    #sidebar[open] summary {
      border-bottom: 1px solid rgba(255,255,255,0.15);
    }
    .player-list { padding: 8px 10px; max-height: 40vh; overflow: auto; }
    .player-row { display:flex; align-items:center; justify-content:space-between; padding:6px 4px; }
    .player-meta { display:flex; align-items:center; gap:8px; }
    .player-dot { width:10px; height:10px; border-radius:50%; outline:1px solid rgba(0,0,0,0.4); }
    .player-gold { font-variant-numeric: tabular-nums; }
    .player-income { font-variant-numeric: tabular-nums; opacity: 0.9; }
    .player-row .cols { display:flex; align-items:center; gap:12px; }
    .player-income small { opacity: 0.75; font-size: 12px; margin-left: 2px; }
#toasts { position: absolute; bottom: 102px; right: 12px; z-index: 50; display: flex; flex-direction: column; gap: 8px; }
.toast { background: rgba(0,0,0,0.75); color:#fff; padding:8px 12px; border-radius:8px; font-size:13px; pointer-events:none; animation: fadeout 3s forwards; }
@keyframes fadeout { 0%{opacity:1; transform:translateY(0)} 80%{opacity:1} 100%{opacity:0; transform:translateY(10px)} }
    .tiny-btn { margin-left: 6px; padding: 2px 6px; font-size: 11px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.12); color: #fff; cursor: pointer; }
    .tiny-btn:hover { background: rgba(255,255,255,0.22); }
    .tiny-btn.on  { background: rgba(46,204,113,0.35); border-color: rgba(46,204,113,0.6); }
    .tiny-btn.off { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.35); opacity: 0.9; }
    .troop-slot { display:flex; flex-direction:column; align-items:center; gap:6px; min-width: 160px; }
  </style>
</head>
<body>
  <div id="game">
    <div id="ui">
      <div>Timer: <span id="timer">10:00</span></div>
      <div>Gold: <span id="gold">500</span></div>
      <div>Army: <span id="army">0</span></div>
      <div>Farms: <span id="farms">0</span></div>
      <div>Income: <span id="income">10</span>/min <button id="toggle-net" class="tiny-btn">NET</button></div>
      <div><button id="toggle-autohire" class="tiny-btn on">Auto-hire: ON</button></div>
    </div>
    <details id="sidebar" open>
      <summary>
        Players & Gold
        <span style="opacity:.8;font-size:12px">(click to toggle)</span>
      </summary>
      <div class="player-list" id="player-list"></div>
    </details>
    <div id="troop-panel">
      <div class="troop-slot">
        <div class="troop-btn" onclick="hire('infantry', 50)">Hire Infantry (50)</div>
        <button id="toggle-autohire-infantry" class="tiny-btn on">Auto: ON</button>
      </div>
      <div class="troop-slot">
        <div class="troop-btn" onclick="hire('archer', 70)">Hire Archer (70)</div>
        <button id="toggle-autohire-archer" class="tiny-btn on">Auto: ON</button>
      </div>
      <div class="troop-slot">
        <div class="troop-btn" onclick="hire('cavalry', 100)">Hire Cavalry (100)</div>
        <button id="toggle-autohire-cavalry" class="tiny-btn on">Auto: ON</button>
      </div>
      <div class="troop-slot">
        <div class="troop-btn" onclick="hire('militia', 30)">Hire Militia (30)</div>
        <button id="toggle-autohire-militia" class="tiny-btn on">Auto: ON</button>
      </div>
    </div>
    <div id="toasts"></div>
  </div>

  <div id="modal-overlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);z-index:10;justify-content:center;align-items:center;">
    <div id="modal" style="background:white;padding:20px;border-radius:10px;min-width:200px;text-align:center;"></div>
  </div>

  <script>
    const farmsMap = new Map();
    const capturedFarms = new Set();
    const farmOwners = new Map(); // key -> { ownerIndex, ownerLabel, troops }
    const farmElements = new Map(); // key -> DOM element for the farm
    const playerColors = ['#ffd700', '#00bfff', '#ff4500', '#32cd32', '#ff69b4', '#ffa500', '#8a2be2', '#00ced1'];
    const castleElements = new Map(); // key -> DOM element for castle

    // --- Auto-hiring (per minute) rates ---
    const autoHireRatesPerMin = {
      militia: 0.05,
      infantry: 0.10,
      archer: 0.10,
      cavalry: 0.20,
    };

    // --- Full unit purchase costs (used by auto-hire when buying) ---
    const unitCosts = {
      infantry: 50,
      archer: 70,
      cavalry: 100,
      militia: 30,
    };

    // --- Loot & targeting tuning ---
    const LOOT_MIN_PCT = 0.05;   // 5%
    const LOOT_MAX_PCT = 0.30;   // 30%
    const RICH_GOLD_THRESHOLD = 800; // when an opponent is "rich", bots will also harass their farms

    function calcRandomLoot(amount) {
      const pct = LOOT_MIN_PCT + Math.random() * (LOOT_MAX_PCT - LOOT_MIN_PCT);
      return Math.max(1, Math.floor(amount * pct));
    }

    // Central Castle ownership model
    let centerDefenseMax = 1000;         // maximum neutral defenders
    let centerDefense = centerDefenseMax; // current neutral defenders until captured
    let centralOwnerIndex = null;        // null => neutral
    let centralGarrison = 0;             // troops stationed if owned
    let centerElement = null;            // DOM element reference
    // Track per-attacker reward progress for neutral guard damage (percentage thresholds)
    const centerDamageProgress = new Map(); // attackerIndex -> last whole percent rewarded
    // Dynamic reward pool for attacking/capturing the center
    const CENTER_POOL_RATE_PER_MIN = 200; // how fast the pool grows while neutral (gold per minute)
    const CENTER_POOL_START = 10000;          // starting pool when neutral at game start
    let centerRewardPool = CENTER_POOL_START; // current pool
    let _centerPoolAcc = 0;               // small accumulator for throttling UI refresh

    // Reward per 1% neutral guard destroyed (tunable)
    const CENTER_REWARD_PER_PERCENT = 300;

    function updateCenterVisual() {
      if (!centerElement) return;
      const span = centerElement.querySelector('span');
      if (centralOwnerIndex === null) {
        if (span) span.innerHTML = `Central Castle — Guard: <img src="army-icon.png" class="army-glyph">${centerDefense} — Pool: ${Math.floor(centerRewardPool)}`;
        centerElement.classList.remove('owned');
        centerElement.style.outlineColor = '';
      } else {
        const color = playerColors[centralOwnerIndex % playerColors.length] || '#fff';
        centerElement.classList.add('owned');
        centerElement.style.outlineColor = color;
        if (span) span.innerHTML = `Central Castle — Owner: Player ${centralOwnerIndex + 1} — Garrison: <img src="army-icon.png" class="army-glyph">${centralGarrison}`;
      }
    }

    function updateFarmVisual(key) {
      const el = farmElements.get(key);
      if (!el) return;
      const span = el.querySelector('span');
      const rec = farmOwners.get(key);
      if (rec) {
        if (span) span.innerHTML = `Farm — ${rec.ownerLabel}: <img src="army-icon.png" class="army-glyph">${rec.troops}`;
        el.classList.add('owned');
        const color = playerColors[rec.ownerIndex % playerColors.length] || '#fff';
        el.style.outlineColor = color;
      } else {
        if (span) span.textContent = 'Farm';
        el.classList.remove('owned');
        el.style.outlineColor = '';
      }
    }

    // Safe playfield bounds so objects don't sit under the bottom HUD
    const SAFE_MIN_Y = 6;   // small top margin
    const SAFE_MAX_Y = 82;  // keep bottom clear of the 90px HUD

    // --- Players / Ownership model ---
    const positionsRaw = [
      [20, 10], [50, 10], [80, 20], [90, 50],
      [80, 80], [50, 90], [20, 80], [10, 50],
    ];
    const positions = positionsRaw.map(([x, y]) => [x, Math.min(Math.max(y, SAFE_MIN_Y), SAFE_MAX_Y)]);
    const players = positions.map(([x, y], i) => ({
      index: i,
      label: `Player ${i + 1}`,
      x, y,
      gold: 500,
      army: 0,
    }));

    // Ensure each player has per-type army buckets
    players.forEach((p) => {
      if (!p._armyByType) p._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
    });

    // --- AI Strategy Profiles ---
    function createAIProfile() {
      const roll = Math.random();
      if (roll < 0.25) {
        // Hoarder: 
        return {
          name: 'Hoarder',
          actionDelayMin: 9000,
          actionDelayMax: 14000,
          sendFracMin: 0.20,
          sendFracMax: 0.40,
          urgentBoost: 1.4,      // 
          recallChance: 0.45,    //
          recallThreshold: 8,
          recallMaxFarms: 3,
          centerAggression: 1.1,
          farmBias: 1.0,
          raidBias: 0.9
        };
      } else if (roll < 0.5) {
        // Skirmisher: 
        return {
          name: 'Skirmisher',
          actionDelayMin: 4000,
          actionDelayMax: 7000,
          sendFracMin: 0.15,
          sendFracMax: 0.35,
          urgentBoost: 1.2,
          recallChance: 0.20,
          recallThreshold: 6,
          recallMaxFarms: 1,
          centerAggression: 0.9,
          farmBias: 1.2,
          raidBias: 1.1
        };
      } else if (roll < 0.75) {
        // Opportunist: 
        return {
          name: 'Opportunist',
          actionDelayMin: 6000,
          actionDelayMax: 10000,
          sendFracMin: 0.25,
          sendFracMax: 0.50,
          urgentBoost: 1.3,
          recallChance: 0.30,
          recallThreshold: 7,
          recallMaxFarms: 2,
          centerAggression: 1.3,
          farmBias: 1.1,
          raidBias: 1.0
        };
      }
      // Balanced (fallback)
      return {
        name: 'Balanced',
        actionDelayMin: 6000,
        actionDelayMax: 12000,
        sendFracMin: 0.25,
        sendFracMax: 0.35,
        urgentBoost: 1.2,
        recallChance: 0.25,
        recallThreshold: 8,
        recallMaxFarms: 2,
        centerAggression: 1.0,
        farmBias: 1.0,
        raidBias: 1.0
      };
    }

    // Assign a random profile to every bot (players 2..8)
    for (let i = 1; i < players.length; i++) {
      players[i].aiProfile = createAIProfile();
    }

    // Castle garrisons: key -> { ownerIndex, troops }
    const castleGarrisons = new Map();
    positions.forEach(([x, y], i) => {
      const key = `${x},${y}`;
      castleGarrisons.set(key, { ownerIndex: i, troops: 0 });
    });

    // Helper: resolve simple 1:1 attrition battle
    function resolveBattle(attacker, defender) {
      const attLeft = Math.max(0, attacker - defender);
      const defLeft = Math.max(0, defender - attacker);
      return { attLeft, defLeft };
    }

    // Reward helper: grant gold for each whole percent of neutral guard destroyed
    function grantCenterGuardReward(attackerIndex, beforeDef, afterDef) {
      if (attackerIndex == null) return;
      // Only while center is neutral (no owner)
      if (centralOwnerIndex !== null) return;
      const prevPct = Math.floor(((centerDefenseMax - beforeDef) / centerDefenseMax) * 100);
      const newPct  = Math.floor(((centerDefenseMax - afterDef)  / centerDefenseMax) * 100);
      if (newPct > prevPct) {
        let steps = newPct - prevPct; // how many whole percents crossed this strike
        const p = players[attackerIndex];
        let totalAward = 0;
        while (steps-- > 0) {
          const stepAward = Math.max(0, Math.floor(centerRewardPool * 0.01)); // 1% of CURRENT pool
          if (stepAward > 0) {
            totalAward += stepAward;
            centerRewardPool = Math.max(0, centerRewardPool - stepAward);
          }
        }
        if (totalAward > 0) {
          p.gold += totalAward;
          if (attackerIndex === 0) {
            gold = p.gold; goldText.textContent = Math.floor(gold);
            showToast(`+${totalAward} gold (center damage)`);
          }
          updateCenterVisual();
        }
      }
      // Record latest awarded percent for this attacker
      centerDamageProgress.set(attackerIndex, newPct);
    }

    // Helper: count farms owned by a player
    function countFarmsOwned(ownerIndex) {
      let n = 0;
      farmOwners.forEach((rec) => { if (rec.ownerIndex === ownerIndex) n++; });
      return n;
    }

    // Estimate expected auto-hire spend per minute using per-type army structure
    function estimateAutoHireCostPerMin(player) {
      if (!player) return 0;
      if (!player._armyByType) player._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      let spend = 0;
      for (const [type, cost] of Object.entries(autoHireRatesPerMin)) {
        const qty = player._armyByType[type] || 0;
        spend += cost * qty;
      }
      // Part 1.2 — floor to integer for UI (always down)
      return Math.floor(spend);
    }

    function fmtTime(s) {
      s = Math.max(0, Math.floor(s));
      const m = Math.floor(s / 60);
      const r = s % 60;
      return `${m.toString().padStart(2,'0')}:${r.toString().padStart(2,'0')}`;
    }

    function endMatch() {
      if (matchEnded) return;
      matchEnded = true;
      // winner by current gold
      const winner = [...players].sort((a,b)=> b.gold - a.gold)[0];
      const container = document.createElement('div');
      container.innerHTML = `
        <h3>Time's up!</h3>
        <div style="margin:8px 0;">Winner: <strong>${winner.label}</strong> (${winner.gold} gold)</div>
      `;
      const btnContinue = document.createElement('button');
      btnContinue.textContent = 'Continue';
      btnContinue.onclick = () => { closeModal(); matchTimeLeft = 600; matchEnded = false; };
      const btnNew = document.createElement('button');
      btnNew.textContent = 'New Game';
      btnNew.style.marginLeft = '10px';
      btnNew.onclick = () => { closeModal(); newGame(); };
      container.append(btnContinue, btnNew);
      showModal(container);
    }

    function newGame() {
      // reset players
      players.forEach((p) => { p.gold = 500; p.army = 0; p._goldAcc = 0; });
      gold = players[0].gold; army = players[0].army;
      goldText.textContent = Math.floor(gold); armyText.textContent = army;

      // reset farms
      farmOwners.clear();
      farmElements.forEach((_, key) => updateFarmVisual(key));
      capturedFarms.clear();
      const lf = countFarmsOwned(0);
      farmsText.textContent = lf;
      incomeText.textContent = 30 + lf * 10 + (centralOwnerIndex === 0 ? 200 : 0);

      // reset central castle
      centerDefense = centerDefenseMax;
      centralOwnerIndex = null;
      centralGarrison = 0;
      centerDamageProgress.clear();
      updateCenterVisual();
      // reset dynamic center reward pool
      centerRewardPool = CENTER_POOL_START;
      _centerPoolAcc = 0;
      updateCenterVisual();

      // sync castles
      for (let i = 0; i < players.length; i++) syncCastleGarrison(i);
      positions.forEach(([x, y]) => updateCastleVisual(`${x},${y}`));

      // reset timer
      matchTimeLeft = 600;
      matchEnded = false;

      // refresh sidebar
      renderPlayerSidebar();
    }

    // Helper: send surviving attackers back to their home castle and add to available army (not garrison)
    function sendBackSurvivors(fromX, fromY, toX, toY, survivors, ownerIndex) {
      if (!survivors || survivors <= 0) return;
      sendTroops(fromX, fromY, toX, toY, null, {
        ownerIndex,
        onArrival: () => {
          // Add survivors to the player's available army pool
          players[ownerIndex].army = (players[ownerIndex].army || 0) + survivors;
          // PART 1.3.5: Attribute survivors to militia bucket
          ensureArmyBuckets(players[ownerIndex]);
          players[ownerIndex]._armyByType.militia += survivors;
          if (ownerIndex === 0) {
            army += survivors;
            armyText.textContent = army;
          }
          syncCastleGarrison(ownerIndex);
        }
      });
    }

    // Keep each player's castle garrison equal to their available army
    function syncCastleGarrison(playerIndex) {
      const [cx, cy] = positions[playerIndex];
      const ckey = `${cx},${cy}`;
      const rec = { ownerIndex: playerIndex, troops: players[playerIndex].army || 0 };
      castleGarrisons.set(ckey, rec);
      updateCastleVisual(ckey);
    }

    // Auto-hire one unit per type if player has enough gold for that type (spends full price per unit)
    function autoHireArmy(player) {
      if (!player) return;
      // Human player's auto-hire can be toggled via UI; AI ignores this flag
      if (player.index === 0 && !autoHireEnabled) return;
      if (!player._armyByType) player._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      let _spent = 0;
      const _added = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      for (const type of Object.keys(unitCosts)) {
        const price = unitCosts[type];
        if ((player.index !== 0 || autoHireTypeEnabled[type]) && player.gold >= price) {
          player.gold -= price;
          player._armyByType[type] += 1;
          player.army = (player.army || 0) + 1;
          syncCastleGarrison(player.index);
          _spent += price;
          _added[type] += 1;
          // Update local UI if it's the human player
          if (player.index === 0) {
            gold = player.gold;
            goldText.textContent = Math.floor(gold);
            army = player.army;
            armyText.textContent = army;
            syncCastleGarrison(0);
          }
        }
      }
      // Show summary toast for local player if anything was hired
      if (player.index === 0 && _spent > 0) {
        const parts = [];
        for (const t of Object.keys(_added)) {
          if (_added[t] > 0) parts.push(`+${_added[t]} ${t}`);
        }
        if (parts.length) showToast(`Auto-hire: ${parts.join(', ')} (-${_spent} gold)`);
      }
    }

    // --- Income toggle ---
    let _showNet = true; // NET by default; toggle switches between NET and GROSS

    // --- Auto-hire toggle (persisted) ---
    let autoHireEnabled = true;
    try {
      const savedAuto = localStorage.getItem('autoHireEnabled');
      if (savedAuto !== null) autoHireEnabled = JSON.parse(savedAuto);
    } catch {}

    // --- Auto-hire per-type toggles (persisted) ---
    let autoHireTypeEnabled = { militia: true, infantry: true, archer: true, cavalry: true };
    try {
      const savedTypes = localStorage.getItem('autoHireTypeEnabled');
      if (savedTypes) {
        const parsed = JSON.parse(savedTypes);
        autoHireTypeEnabled = { ...autoHireTypeEnabled, ...parsed };
      }
    } catch {}

    // Continuous per-second income with integer gold increases
    players.forEach(p => p._goldAcc = 0);
    let _lastTs = performance.now();
    let _autoHireAcc = 0; // seconds accumulator for auto-hiring per minute
    function mainLoop(ts) {
      const dt = Math.max(0, (ts - _lastTs) / 1000);
      _lastTs = ts;
      // per-player income accumulation
      players.forEach((p) => {
        const farmsOwned = countFarmsOwned(p.index);
        const hasCenter = (centralOwnerIndex === p.index) ? 200 : 0;
        const incomePerMin = 30 + farmsOwned * 10 + hasCenter; // +200 if owns center
        const incomePerSec = incomePerMin / 60;
        p._goldAcc += incomePerSec * dt;
        if (p._goldAcc >= 1) {
          const whole = Math.floor(p._goldAcc);
          p._goldAcc -= whole;
          p.gold += whole;
          if (p.index === 0) {
            gold = p.gold;
            goldText.textContent = Math.floor(gold);
          }
        }
        if (p.index === 0) {
          farmsText.textContent = farmsOwned;
          const gross = 30 + farmsOwned * 10 + (centralOwnerIndex === 0 ? 200 : 0);
          const expense = estimateAutoHireCostPerMin(players[0]);
          const incomeVal = _showNet ? Math.max(0, Math.floor(gross - expense)) : Math.floor(gross);
          incomeText.textContent = incomeVal;
        }
      });
      // Center reward pool accumulation (per second). When owned, pay owner directly per second.
      _centerPoolAcc += dt;
      const perSecPool = CENTER_POOL_RATE_PER_MIN / 60;
      if (centralOwnerIndex === null) {
        centerRewardPool += perSecPool * dt;
        // Throttle pool text updates to ~2Hz to avoid layout thrash
        if (_centerPoolAcc >= 0.5) { updateCenterVisual(); _centerPoolAcc = 0; }
      } else {
        const owner = players[centralOwnerIndex];
        if (owner) {
          owner.gold += perSecPool * dt;
          if (centralOwnerIndex === 0) {
            gold = owner.gold;
            goldText.textContent = Math.floor(gold);
          }
        }
        _centerPoolAcc = 0; // no UI updates for pool when owned
      }
      // Auto-hiring update (run once per minute, catch up if tab was inactive)
      _autoHireAcc += dt;
      if (_autoHireAcc >= 60) {
        const ticks = Math.floor(_autoHireAcc / 60);
        _autoHireAcc -= ticks * 60;
        for (let i = 0; i < ticks; i++) {
          players.forEach((p) => autoHireArmy(p));
        }
      }
      // Match timer update
      if (!matchEnded) {
        matchTimeLeft -= dt;
        if (timerEl) timerEl.textContent = fmtTime(matchTimeLeft);
        if (matchTimeLeft <= 0) {
          endMatch();
        }
      }
      // Throttled sidebar refresh (~2 times/sec)
      mainLoop._acc = (mainLoop._acc || 0) + dt;
      if (mainLoop._acc >= 0.5) { renderPlayerSidebar(); mainLoop._acc = 0; }
      requestAnimationFrame(mainLoop);
    }
    requestAnimationFrame(mainLoop);
    const game = document.getElementById("game");
    const goldText = document.getElementById("gold");
    const armyText = document.getElementById("army");
    const farmsText = document.getElementById("farms");
    const incomeText = document.getElementById("income");
    const timerEl = document.getElementById('timer');
    const toggleNetBtn = document.getElementById('toggle-net');
    if (toggleNetBtn) {
      toggleNetBtn.onclick = () => {
        _showNet = !_showNet;
        toggleNetBtn.textContent = _showNet ? 'NET' : 'GROSS';
        // Refresh HUD income immediately
        const farmsOwned = countFarmsOwned(0);
        const gross = 30 + farmsOwned * 10 + (centralOwnerIndex === 0 ? 200 : 0);
        const expense = estimateAutoHireCostPerMin(players[0]);
        const incomeVal = _showNet ? Math.max(0, Math.floor(gross - expense)) : Math.floor(gross);
        incomeText.textContent = incomeVal;
        // Refresh sidebar
        renderPlayerSidebar();
      };
    }

    const toggleAutoBtn = document.getElementById('toggle-autohire');
    function refreshAutoHireBtn() {
      if (!toggleAutoBtn) return;
      toggleAutoBtn.textContent = autoHireEnabled ? 'Auto-hire: ON' : 'Auto-hire: OFF';
      toggleAutoBtn.classList.remove('on','off');
      toggleAutoBtn.classList.add(autoHireEnabled ? 'on' : 'off');
      toggleAutoBtn.title = autoHireEnabled ? 'Automatic hiring is enabled' : 'Automatic hiring is disabled';
    }
    refreshAutoHireBtn();
    if (toggleAutoBtn) {
      toggleAutoBtn.onclick = () => {
        autoHireEnabled = !autoHireEnabled;
        try { localStorage.setItem('autoHireEnabled', JSON.stringify(autoHireEnabled)); } catch {}
        refreshAutoHireBtn();
        showToast(autoHireEnabled ? 'Auto-hire enabled' : 'Auto-hire disabled');
      };
    }

    // --- Auto-hire per-type button wiring and state ---
    const perTypeBtns = {
      militia: document.getElementById('toggle-autohire-militia'),
      infantry: document.getElementById('toggle-autohire-infantry'),
      archer: document.getElementById('toggle-autohire-archer'),
      cavalry: document.getElementById('toggle-autohire-cavalry'),
    };

    function refreshPerTypeBtns() {
      for (const t of Object.keys(perTypeBtns)) {
        const btn = perTypeBtns[t];
        if (!btn) continue;
        const on = !!autoHireTypeEnabled[t];
        btn.textContent = `${t.charAt(0).toUpperCase()+t.slice(1)}: ${on ? 'ON' : 'OFF'}`;
        btn.classList.remove('on','off');
        btn.classList.add(on ? 'on' : 'off');
        btn.title = on ? `Auto-hire ${t} is enabled` : `Auto-hire ${t} is disabled`;
      }
    }
    refreshPerTypeBtns();

    for (const t of Object.keys(perTypeBtns)) {
      const btn = perTypeBtns[t];
      if (!btn) continue;
      btn.onclick = () => {
        autoHireTypeEnabled[t] = !autoHireTypeEnabled[t];
        try { localStorage.setItem('autoHireTypeEnabled', JSON.stringify(autoHireTypeEnabled)); } catch {}
        refreshPerTypeBtns();
        showToast(`${t} auto-hire ${autoHireTypeEnabled[t] ? 'enabled' : 'disabled'}`);
      };
    }
    let matchTimeLeft = 600; // 10 minutes
    let matchEnded = false;
    let gold = 500;
    let army = 0;

    // Sidebar DOM refs and render
    const playerListEl = document.getElementById('player-list');

    function getTotalTroops(ownerIndex) {
      let total = 0;
      // idle troops (purchased but not sent)
      total += players[ownerIndex].army || 0;
      // castle garrison
      const ckey = `${positions[ownerIndex][0]},${positions[ownerIndex][1]}`;
      const cg = castleGarrisons.get(ckey);
      if (cg && cg.ownerIndex === ownerIndex) total += cg.troops;
      // farms
      farmOwners.forEach((rec) => { if (rec.ownerIndex === ownerIndex) total += rec.troops; });
      return total;
    }

    function renderPlayerSidebar() {
      if (!playerListEl) return;
      const frag = document.createDocumentFragment();
      [...players].sort((a,b)=> b.gold - a.gold).forEach((p) => {
        const row = document.createElement('div');
        row.className = 'player-row';

        // left: color dot + name
        const meta = document.createElement('div');
        meta.className = 'player-meta';
        const dot = document.createElement('div');
        dot.className = 'player-dot';
        dot.style.background = playerColors[p.index % playerColors.length] || '#fff';
        const name = document.createElement('div');
        name.textContent = p.label;
        meta.append(dot, name);

        // middle: live income per minute (net: gross income minus auto-hire estimate)
        const farmsOwned = countFarmsOwned(p.index);
        const hasCenter = (centralOwnerIndex === p.index) ? 200 : 0;
        const gross = 30 + farmsOwned * 10 + hasCenter;
        const expense = estimateAutoHireCostPerMin(p);
        const incomeVal = _showNet ? Math.max(0, Math.floor(gross - expense)) : Math.floor(gross);
        const incomeEl = document.createElement('div');
        incomeEl.className = 'player-income';
        incomeEl.innerHTML = `${incomeVal}<small>/min</small>`;
        incomeEl.title = _showNet
          ? `Income: ${Math.floor(gross)}/min\nAuto-hire: -${Math.floor(expense)}/min\nNet: ${incomeVal}/min`
          : `Gross income: ${Math.floor(gross)}/min`;

        // right: current gold
        const goldEl = document.createElement('div');
        goldEl.className = 'player-gold';
        goldEl.textContent = `${Math.floor(p.gold)}`;

        const cols = document.createElement('div');
        cols.className = 'cols';
        cols.append(incomeEl, goldEl);

        row.append(meta, cols);
        frag.appendChild(row);
      });
      playerListEl.innerHTML = '';
      playerListEl.appendChild(frag);
    }

    function showModal(content) {
      const modal = document.getElementById("modal");
      modal.innerHTML = '';
      modal.appendChild(content);
      document.getElementById("modal-overlay").style.display = "flex";
    }

    function closeModal() {
      document.getElementById("modal-overlay").style.display = "none";
    }

    function createInputPopup(title, maxAmount, callback) {
      const container = document.createElement("div");
      const titleElem = document.createElement("div");
      titleElem.textContent = title;
      titleElem.style.marginBottom = "10px";
      const input = document.createElement("input");
      input.type = "number";
      input.value = "1";
      input.min = "1";
      input.max = maxAmount;
      input.style.width = "100%";
      input.style.marginBottom = "10px";

      const ok = document.createElement("button");
      ok.textContent = "OK";
      const cancel = document.createElement("button");
      cancel.textContent = "Cancel";
      cancel.style.marginLeft = "10px";

      function validate() {
        ok.disabled = parseInt(input.value) > maxAmount || parseInt(input.value) < 1;
      }

      input.oninput = validate;
      validate();

      ok.onclick = () => {
        callback(parseInt(input.value));
        closeModal();
      };
      cancel.onclick = closeModal;

      container.append(titleElem, input, ok, cancel);
      showModal(container);
    }

    function createInfoPopup(message) {
      const container = document.createElement("div");
      container.innerHTML = `<div style='margin-bottom:10px;'>${message}</div>`;
      const btn = document.createElement("button");
      btn.textContent = "OK";
      btn.onclick = closeModal;
      container.appendChild(btn);
      showModal(container);
    }

    function showToast(message) {
      const c = document.getElementById('toasts');
      if (!c) return;
      const el = document.createElement('div');
      el.className = 'toast';
      el.textContent = message;
      c.appendChild(el);
      setTimeout(() => { if (el.parentNode === c) c.removeChild(el); }, 3000);
    }

    function createTroopPopup(troopTypes, maxAmounts, callback) {
      const container = document.createElement("div");
      container.innerHTML = "<h3>Select Troops</h3>";
      const troopInputs = {};

      troopTypes.forEach((type) => {
        const div = document.createElement("div");
        div.textContent = `${type}: `;
        const input = document.createElement("input");
        input.type = "number";
        input.value = "0";
        input.min = "0";
        input.max = maxAmounts[type];
        input.style.marginLeft = "5px";
        div.appendChild(input);
        container.appendChild(div);
        troopInputs[type] = input;
      });

      const ok = document.createElement("button");
      ok.textContent = "OK";
      const cancel = document.createElement("button");
      cancel.textContent = "Cancel";
      cancel.style.marginLeft = "10px";

      ok.onclick = () => {
        const selected = {};
        let totalSelected = 0;
        Object.keys(troopInputs).forEach((type) => {
          const amount = parseInt(troopInputs[type].value);
          if (amount > 0) {
            selected[type] = amount;
            totalSelected += amount;
          }
        });
        callback(selected, totalSelected);
        closeModal();
      };

      cancel.onclick = closeModal;
      container.append(ok, cancel);
      showModal(container);
    }

    // === Per-type army helpers (1.3.1) ===
    function ensureArmyBuckets(p) {
      if (!p._armyByType) p._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      return p._armyByType;
    }

    function deductArmyByType(playerIndex, selected) {
      const p = players[playerIndex];
      const buckets = ensureArmyBuckets(p);
      for (const k of Object.keys(buckets)) {
        const want = selected[k] || 0;
        buckets[k] = Math.max(0, (buckets[k] || 0) - want);
      }
    }

    function sendTroops(fromX, fromY, toX, toY, durationSeconds = null, options = {}) {
      const { onArrival = null, payload = null, ownerIndex = 0 } = options;
      const isLocalPlayer = fromX === localPlayerPos.x && fromY === localPlayerPos.y;

      const dx = toX - fromX;
      const dy = toY - fromY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const fullDistance = Math.sqrt(100 * 100 + 100 * 100);
      const travelDuration = durationSeconds ?? (distance / fullDistance) * 60; // seconds
      const travelMillis = travelDuration * 1000;

      // Visual icon for everyone
      const icon = document.createElement('img');
      icon.src = 'army-icon.png';
      icon.className = 'army-icon bubble';
      icon.style.left = `${fromX}%`;
      icon.style.top = `${fromY}%`;
      const color = playerColors[ownerIndex % playerColors.length] || '#fff';
      icon.style.borderColor = color;
      game.appendChild(icon);

      // Draw movement line only for local player
      let line = null;
      if (isLocalPlayer) {
        line = document.createElement('div');
        line.style.position = 'absolute';
        line.style.left = '0';
        line.style.top = '0';
        line.style.width = '100%';
        line.style.height = '100%';
        line.style.pointerEvents = 'none';
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.style.position = 'absolute';
        svg.style.left = '0';
        svg.style.top = '0';
        const linePath = document.createElementNS(svgNS, 'line');
        linePath.setAttribute('x1', `${fromX}%`);
        linePath.setAttribute('y1', `${fromY}%`);
        linePath.setAttribute('x2', `${toX}%`);
        linePath.setAttribute('y2', `${toY}%`);
        linePath.setAttribute('stroke', color);
        linePath.setAttribute('stroke-width', '2');
        svg.appendChild(linePath);
        line.appendChild(svg);
        game.appendChild(line);
      }

      const startTime = performance.now();
      function animate(time) {
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / travelMillis, 1);
        const currentX = fromX + dx * progress;
        const currentY = fromY + dy * progress;
        icon.style.left = `${currentX}%`;
        icon.style.top = `${currentY}%`;
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          if (icon.parentNode === game) game.removeChild(icon);
          if (line && line.parentNode === game) game.removeChild(line);
          if (typeof onArrival === 'function') {
            onArrival(payload);
          } else {
            const key = `${Math.round(toX)},${Math.round(toY)}`;
            if (farmsMap.has(key)) {
              const rec = farmOwners.get(key) || { ownerIndex, ownerLabel: `Player ${ownerIndex + 1}`, troops: 0 };
              farmOwners.set(key, rec);
              updateFarmVisual(key);
            }
          }
        }
      }
      requestAnimationFrame(animate);
    }
    function updateCastleVisual(key) {
      const el = castleElements.get(key);
      if (!el) return;
      const span = el.querySelector('span');
      // deduce owner index from key (each castle belongs to a fixed player by position)
      const [x, y] = key.split(',').map(Number);
      const ownerIndex = positions.findIndex(([px, py]) => px === x && py === y);
      const color = playerColors[ownerIndex % playerColors.length] || '#fff';
      el.classList.add('owned');
      el.style.outlineColor = color;
      const troops = players[ownerIndex] ? (players[ownerIndex].army || 0) : 0;
      if (span) span.textContent = `Player ${ownerIndex + 1} — Garrison: ${troops}`;
    }

    function hire(type, cost) {
      const maxBuy = Math.floor(gold / cost);
      if (maxBuy < 1) {
        createInfoPopup("Not enough gold!");
        return;
      }

      createInputPopup(`How many ${type}s do you want to hire?`, maxBuy, (count) => {
        const total = count * cost;
        gold -= total; players[0].gold = gold;
        army += count; players[0].army = army;
        goldText.textContent = Math.floor(gold);
        armyText.textContent = army;
        syncCastleGarrison(0);
        createInfoPopup(`Hired ${count} ${type}(s)!`);
      });
    }

    function addObject(type, x, y, label, onClick) {
      const div = document.createElement("div");
      div.className = `object ${type}`;
      div.style.left = `${x}%`;
      div.style.top = `${y}%`;
      div.dataset.x = x;
      div.dataset.y = y;

      const img = document.createElement("img");
      img.src = type === "castle" ? "castle.png" : type === "center" ? "center_castle.png" : "mine.png";
      img.style.width = type === "center" ? "72px" : type === "mine" ? "48px" : "64px";
      div.appendChild(img);

      if (label) {
        const span = document.createElement("span");
        span.textContent = label;
        div.appendChild(span);
      }

      div.onclick = onClick;
      game.appendChild(div);
      return div;
    }

    // Set local player position from first castle (Player 1)
    let localPlayerPos = { x: positions[0][0], y: positions[0][1] };

    // Center castle — capturable; owner gets +200/min
    centerElement = addObject("center", 50, 50, "Central Castle — Guard: " + centerDefenseMax, () => {
      if (army > 0) {
        const b = ensureArmyBuckets(players[0]);
        createTroopPopup(["infantry", "archer", "cavalry", "militia"], {
          infantry: b.infantry || 0,
          archer: b.archer || 0,
          cavalry: b.cavalry || 0,
          militia: b.militia || 0
        }, (selectedTroops, totalSent) => {
          army -= totalSent; players[0].army = army; armyText.textContent = army;
          deductArmyByType(0, selectedTroops);
          syncCastleGarrison(0);
          const time = Math.floor(Math.random() * 5) + 3;
          sendTroops(localPlayerPos.x, localPlayerPos.y, 50, 50, time, {
            ownerIndex: 0,
            payload: { sent: totalSent, attackerIndex: 0 },
            onArrival: (p) => {
              if (centralOwnerIndex === null) {
                // fight neutral defenders and grant per-1% rewards
                const before = centerDefense;
                const { attLeft, defLeft } = resolveBattle(p.sent, before);
                centerDefense = defLeft;
                grantCenterGuardReward(p.attackerIndex, before, centerDefense);
                if (attLeft > 0 && defLeft === 0) {
                  centralOwnerIndex = p.attackerIndex;
                  centralGarrison = attLeft; // survivors stay as central garrison
                  // Award dynamic pool to the captor
                  if (centerRewardPool > 0) {
                    const award = Math.floor(centerRewardPool);
                    players[p.attackerIndex].gold += award;
                    if (p.attackerIndex === 0) {
                      gold = players[0].gold; goldText.textContent = Math.floor(gold);
                      showToast(`+${award} gold (center pool)`);
                    }
                    centerRewardPool = 0;
                    updateCenterVisual();
                  }
                }
              } else if (centralOwnerIndex === p.attackerIndex) {
                // reinforce own center
                centralGarrison += p.sent;
              } else {
                // fight current owner's garrison
                const { attLeft, defLeft } = resolveBattle(p.sent, centralGarrison);
                if (attLeft > 0 && defLeft === 0) {
                  centralOwnerIndex = p.attackerIndex;
                  centralGarrison = attLeft;
                  // Award dynamic pool to the captor
                  if (centerRewardPool > 0) {
                    const award = Math.floor(centerRewardPool);
                    players[p.attackerIndex].gold += award;
                    if (p.attackerIndex === 0) {
                      gold = players[0].gold; goldText.textContent = Math.floor(gold);
                      showToast(`+${award} gold (center pool)`);
                    }
                    centerRewardPool = 0;
                    updateCenterVisual();
                  }
                } else {
                  centralGarrison = defLeft;
                }
              }
              updateCenterVisual();
            }
          });
          createInfoPopup(`Marching to Central Castle. Arrival in ${time} seconds.`);
        });
      } else {
        createInfoPopup("No troops available!");
      }
    });

    positions.forEach(([x, y], index) => {
      const isLocal = index === 0;
      const label = `Player ${index + 1}`;
      const onClick = () => {
        if (isLocal) {
          const garrisonNow = players[0].army || 0;
          createInfoPopup(`Your castle garrison: ${garrisonNow}`);
        } else {
          // Attack enemy castle
          if (army > 0) {
            const b = ensureArmyBuckets(players[0]);
            createTroopPopup(["infantry", "archer", "cavalry", "militia"], {
              infantry: b.infantry || 0,
              archer: b.archer || 0,
              cavalry: b.cavalry || 0,
              militia: b.militia || 0
            }, (selectedTroops, totalSent) => {
              army -= totalSent; players[0].army = army; armyText.textContent = army;
              deductArmyByType(0, selectedTroops);
              syncCastleGarrison(0);
              const time = Math.floor(Math.random() * 5) + 3;
              const key = `${x},${y}`;
              sendTroops(localPlayerPos.x, localPlayerPos.y, x, y, time, {
                ownerIndex: 0,
                payload: { key, defenderIndex: index, sent: totalSent, attackerIndex: 0, originX: localPlayerPos.x, originY: localPlayerPos.y, targetX: x, targetY: y },
                onArrival: (p) => {
                  const defenderArmy = players[p.defenderIndex].army || 0;
                  const { attLeft, defLeft } = resolveBattle(p.sent, defenderArmy);
                  players[p.defenderIndex].army = defLeft;
                  syncCastleGarrison(p.defenderIndex);
                  if (attLeft > 0 && defLeft === 0) {
                    const victim = players[p.defenderIndex];
                    const loot = calcRandomLoot(victim.gold);
                    victim.gold = Math.max(0, victim.gold - loot);
                    players[0].gold += loot; gold = players[0].gold; goldText.textContent = Math.floor(gold);
                    showToast(`Looted +${loot} gold`);
                    createInfoPopup(`Raid successful! Looted ${loot} gold from ${victim.label}.`);
                    // send survivors back to our castle with visible movement
                    sendBackSurvivors(p.targetX, p.targetY, p.originX, p.originY, attLeft, p.attackerIndex);
                  } else if (defLeft > 0) {
                    createInfoPopup(`Raid repelled! Defender left: ${defLeft}.`);
                  } else {
                    createInfoPopup(`Both forces annihilated.`);
                  }
                }
              });
              createInfoPopup(`Attacking ${label}. Arrival in ${time} seconds.`);
            });
          } else {
            createInfoPopup("No troops available!");
          }
        }
      };
      const div = addObject("castle", x, y, label, onClick);
      const ckey = `${x},${y}`;
      castleElements.set(ckey, div);
      const color = playerColors[index % playerColors.length] || '#fff';
      div.classList.add('owned');
      div.style.outlineColor = color;
      // set initial garrison label
      const rec = castleGarrisons.get(ckey);
      const span = div.querySelector('span');
      if (span) span.innerHTML = `${label} — Garrison: <img src="army-icon.png" class="army-glyph">${rec ? rec.troops : 0}`;
      if (isLocal) {
        div.classList.add("local-player");
      }
    });

    for (let i = 0; i < players.length; i++) syncCastleGarrison(i);
    positions.forEach(([x, y]) => updateCastleVisual(`${x},${y}`));
    updateCenterVisual();

    // Farms (random generation)
    const farms = [];
    const minX = 10, maxX = 90;
    const minY = 10, maxY = SAFE_MAX_Y - 2; // keep farms above the HUD
    while (farms.length < 24) {
      const x = Math.floor(Math.random() * (maxX - minX)) + minX;
      const y = Math.floor(Math.random() * (maxY - minY)) + minY;
      farms.push([x, y]);
    }
    farms.forEach(([x, y]) => {
      const key = `${x},${y}`;
      farmsMap.set(key, true);
      const el = addObject('mine', x, y, 'Farm', () => {
        const owner = farmOwners.get(key);
        const isOurs = owner && owner.ownerIndex === 0;
        if (isOurs && owner.troops > 0) {
          // Recall interface
          createInputPopup(`Recall from your farm (max ${owner.troops})`, owner.troops, (count) => {
            // send back to local castle
            owner.troops -= count;
            farmOwners.set(key, owner);
            updateFarmVisual(key);
            const time = Math.floor(Math.random() * 5) + 3;
                sendTroops(x, y, localPlayerPos.x, localPlayerPos.y, time, {
                  ownerIndex: 0,
                  onArrival: () => {
                    // Move recalled troops into available army and sync castle UI
                    players[0].army = (players[0].army || 0) + count;
                    ensureArmyBuckets(players[0]);
                    players[0]._armyByType.militia += count;
                    army += count;
                    armyText.textContent = army;
                    syncCastleGarrison(0);
                    showToast(`Recalled +${count} troops`);
                  }
                });
          });
          return;
        }
        // Otherwise behave as attack/send as before
        if (army > 0) {
          const b = ensureArmyBuckets(players[0]);
          createTroopPopup(['infantry', 'archer', 'cavalry', 'militia'], {
            infantry: b.infantry || 0,
            archer: b.archer || 0,
            cavalry: b.cavalry || 0,
            militia: b.militia || 0
          }, (selectedTroops, totalSent) => {
            army -= totalSent;
            armyText.textContent = army;
            players[0].army = army;
            deductArmyByType(0, selectedTroops);
            syncCastleGarrison(0);
            const time = Math.floor(Math.random() * 5) + 3;
            const ownerIndex = 0; // local player
            const ownerLabel = 'Player 1';
            sendTroops(localPlayerPos.x, localPlayerPos.y, x, y, time, {
              ownerIndex,
              payload: { key, ownerIndex, ownerLabel, troops: totalSent },
              onArrival: (p) => {
                const existing = farmOwners.get(p.key);
                if (existing && existing.ownerIndex !== p.ownerIndex) {
                  // Battle on the farm
                  const { attLeft, defLeft } = resolveBattle(p.troops, existing.troops);
                  if (attLeft > 0) {
                    farmOwners.set(p.key, { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: attLeft });
                  } else {
                    farmOwners.set(p.key, { ownerIndex: existing.ownerIndex, ownerLabel: existing.ownerLabel, troops: defLeft });
                  }
                } else {
                  const rec = existing || { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: 0 };
                  rec.ownerIndex = p.ownerIndex; rec.ownerLabel = p.ownerLabel; rec.troops += p.troops;
                  farmOwners.set(p.key, rec);
                }
                updateFarmVisual(p.key);
                const lf = countFarmsOwned(0);
                farmsText.textContent = lf;
                {
                  const gross = 30 + lf * 10 + (centralOwnerIndex === 0 ? 200 : 0);
                  const expense = estimateAutoHireCostPerMin(players[0]);
                  const net = Math.max(0, Math.floor(gross - expense));
                  incomeText.textContent = net;
                }
              }
            });
            createInfoPopup(`Sending troops to farm. Arrival in ${time} seconds.`);
          });
        } else {
          createInfoPopup('No troops available!');
        }
      });
      el.dataset.key = key;
      farmElements.set(key, el);
    });

    // --- AI Farm Recall Helpers ---
    function parseKeyToXY(key) {
      const [sx, sy] = key.split(',');
      return [Number(sx), Number(sy)];
    }

    // Recall troops from up to maxFarms AI-owned farms that have at least `threshold` troops.
    // Returns total number of troops recalled (sum across farms).
    function aiRecallFromFarms(ai, threshold = 10, maxFarms = 2) {
      const owned = [];
      farmOwners.forEach((rec, key) => {
        if (rec.ownerIndex === ai.index && (rec.troops || 0) >= threshold) {
          owned.push({ key, troops: rec.troops });
        }
      });
      if (owned.length === 0) return 0;
      // Recall from the largest farms first
      owned.sort((a, b) => b.troops - a.troops);
      const chosen = owned.slice(0, maxFarms);
      let total = 0;
      chosen.forEach(({ key, troops }) => {
        const count = troops; // recall all from that farm
        const rec = farmOwners.get(key);
        if (!rec || rec.troops < count) return;
        rec.troops -= count;
        farmOwners.set(key, rec);
        updateFarmVisual(key);
        const [fx, fy] = parseKeyToXY(key);
        // animate recall back to AI's castle
        sendTroops(fx, fy, ai.x, ai.y, null, {
          ownerIndex: ai.index,
          onArrival: () => {
            players[ai.index].army = (players[ai.index].army || 0) + count;
            ensureArmyBuckets(players[ai.index]);
            players[ai.index]._armyByType.militia += count; // attribute as militia for upkeep
            syncCastleGarrison(ai.index);
          }
        });
        total += count;
      });
      return total;
    }

    // --- Smarter AI Planning Helpers ---
    function distSq(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; }

    function getRichOpponent(ai) {
      let bestIdx = -1;
      let bestGold = -1;
      players.forEach((p) => {
        if (p.index === ai.index) return;
        if (p.gold > bestGold) { bestGold = p.gold; bestIdx = p.index; }
      });
      return { index: bestIdx, gold: Math.floor(Math.max(0, bestGold)) };
    }

    function pickBestFarmTarget(ai) {
      // Prefer: neutral farms first; otherwise enemy farms with the fewest defenders.
      const rich = getRichOpponent(ai);
      let best = null;
      farmsMap.forEach((_, key) => {
        const rec = farmOwners.get(key) || null;
        const [fx, fy] = key.split(',').map(Number);
        if (!rec) {
          // neutral farm
          const score = 120000 - distSq(ai.x, ai.y, fx, fy) * 0.5; // higher priority + softer distance penalty
          if (!best || score > best.score) best = { type: 'neutral-farm', key, fx, fy, def: 0, score };
        } else if (rec.ownerIndex !== ai.index) {
          const def = rec.troops || 0;
          const richBonus = (rich.index === rec.ownerIndex && rich.gold >= RICH_GOLD_THRESHOLD) ? 20000 : 0;
          const score = 50000 - def*5000 - distSq(ai.x, ai.y, fx, fy) * 0.5 + richBonus; // harass rich opponents' farms
          if (!best || score > best.score) best = { type: 'enemy-farm', key, fx, fy, def, score };
        }
      });
      return best; // {key, fx, fy, def}
    }

    function pickBestCastleRaid(ai) {
      // Weighted roulette by current gold among opponents; probability ~ gold / sum(gold)
      const pool = [];
      let sum = 0;
      players.forEach((p) => {
        if (p.index === ai.index) return;
        const w = Math.max(0, Math.floor(p.gold));
        if (w > 0) { pool.push(p.index); sum += w; }
      });
      if (pool.length === 0) return null;
      let pick = pool[0];
      if (sum > 0) {
        let r = Math.random() * sum;
        for (const idx of pool) {
          const w = Math.max(0, Math.floor(players[idx].gold));
          if (r < w) { pick = idx; break; }
          r -= w;
        }
      }
      const [cx, cy] = positions[pick];
      const def = players[pick].army || 0;
      return { defenderIndex: pick, cx, cy, def };
    }

    function canTakeCenter(ai, sendAmount) {
      if (centralOwnerIndex === null) {
        return sendAmount > centerDefense; // beat neutral guard
      }
      if (centralOwnerIndex === ai.index) return false; // already own
      return sendAmount > centralGarrison; // beat current owner's garrison
    }

    // --- Value/Difficulty Scoring Helpers ---
    function travelPenalty(ax, ay, bx, by) {
      const d = Math.hypot(ax - bx, ay - by); // 0..~141 on 0..100 grid
      return d * 3; // softer distance penalty -> чаще выбираем фермы
    }

    function scoreCenter(ai, send) {
      const timeLeftMin = Math.max(0, matchTimeLeft / 60);
      const penalty = travelPenalty(ai.x, ai.y, 50, 50) * 0.5; // center is strategically important → distance hurts less
      let score = -Infinity;

      if (centralOwnerIndex === null) {
        // Neutral: reward for damage (per full percent crossed)
        const potentialDamage = Math.min(send, centerDefense);
        const steps = Math.floor(potentialDamage / (centerDefenseMax / 100));
        const reward = steps * CENTER_REWARD_PER_PERCENT;
        let bonus = 0;
        if (centerDefense < 400) bonus += 800; // low guard → extra attractive
        // Only include centerRewardPool if neutral
        let poolAdd = (centralOwnerIndex === null ? (send > centerDefense ? Math.floor(centerRewardPool) : 0) : 0);
        score = reward + bonus + poolAdd - penalty;
      } else if (centralOwnerIndex !== ai.index) {
        // Owned by someone else: value is +200/min for remaining time if we can capture now
        if (send > centralGarrison) {
          let value = 200 * timeLeftMin;
          if (centralGarrison < 200) value += 1200; // thin garrison → big opportunity
          // Only add centerRewardPool if center is neutral (should not happen here, but for safety)
          value += (centralOwnerIndex === null ? Math.floor(centerRewardPool) : 0);
          score = value - penalty;
        }
      }

      // Endgame push: last 3 minutes → center becomes even more desirable
      if (matchTimeLeft <= 180 && score > -Infinity) score *= 1.4;
      return score;
    }

    function scoreFarm(ai, farmTarget, send) {
      const timeLeftMin = Math.max(0, matchTimeLeft / 60);
      const penalty = travelPenalty(ai.x, ai.y, farmTarget.fx, farmTarget.fy);
      const def = farmTarget.def || 0;
      if (send <= def) return -Infinity; // cannot win
      // Income gain: +10/min for the remaining time if we flip or capture
      const incomeGain = 10 * timeLeftMin;
      // Neutral farms are even more attractive
      const neutralBonus = (farmTarget.type === 'neutral-farm') ? 80 : 0;
      // Softness bonus: the fewer defenders, the more attractive (0..180)
      const softness = Math.max(0, 6 - def) * 30;
      return incomeGain + neutralBonus + softness - penalty;
    }

    // --- Simple AI ---
    function aiHireAndAct(ai) {
      // 1) Consolidate sometimes (pull back from farms) — per profile
      const prof = ai.aiProfile || { recallChance: 0.25, recallThreshold: 8, recallMaxFarms: 2 };
      if (Math.random() < prof.recallChance) {
        const recalled = aiRecallFromFarms(ai, prof.recallThreshold, prof.recallMaxFarms);
        if (recalled > 0) return; // wait for troops to come back this cycle
      }

      // 2) Buy militia if possible (keeps AI active)
      const militiaCost = 30;
      const canBuy = Math.floor(ai.gold / militiaCost);
      if (canBuy > 0) {
        const toBuy = Math.min(canBuy, 5 + Math.floor(Math.random() * 10));
        ai.gold -= toBuy * militiaCost;
        ai.army += toBuy;
        ensureArmyBuckets(ai);
        ai._armyByType.militia += toBuy;
      }

      // 3) Decide send fraction based on time pressure — per profile
      const urgent = (matchTimeLeft <= 120); // last 2 minutes
      const baseFrac = prof.sendFracMin + Math.random() * (prof.sendFracMax - prof.sendFracMin);
      const frac = urgent ? Math.min(0.9, baseFrac * prof.urgentBoost) : baseFrac;
      let send = Math.max(1, Math.floor(ai.army * frac));
      if (send <= 0) return;

      // 4) Priorities by expected value vs difficulty
      const farmTarget = pickBestFarmTarget(ai);
      let farmDecision = { score: -Infinity, amount: 0 };
      if (farmTarget && ai.army > farmTarget.def) {
        const need = Math.min(ai.army, Math.max(1, farmTarget.def + 1));
        const sendFarm = Math.max(1, Math.min(send, need));
        const s = scoreFarm(ai, farmTarget, sendFarm) * (prof.farmBias || 1);
        farmDecision = { score: s, amount: sendFarm };
      }

      const centerScore = scoreCenter(ai, send) * (prof.centerAggression || 1);

      // Choose higher score among center and farm; if both are poor, we'll consider a raid next
      if (centerScore > farmDecision.score && centerScore > 0) {
        // Attack center with `send`
        ai.army -= send;
        if (ai._armyByType) {
          const take = Math.min(send, ai._armyByType.militia || 0);
          ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
        }
        syncCastleGarrison(ai.index);
        sendTroops(ai.x, ai.y, 50, 50, null, {
          ownerIndex: ai.index,
          payload: { sent: send, attackerIndex: ai.index },
          onArrival: (p) => {
            if (centralOwnerIndex === null) {
              const before = centerDefense;
              const { attLeft, defLeft } = resolveBattle(p.sent, before);
              centerDefense = defLeft;
              grantCenterGuardReward(p.attackerIndex, before, centerDefense);
              if (attLeft > 0 && defLeft === 0) {
                centralOwnerIndex = p.attackerIndex; centralGarrison = attLeft;
                // Award dynamic pool to the captor
                if (centerRewardPool > 0) {
                  const award = Math.floor(centerRewardPool);
                  players[p.attackerIndex].gold += award;
                  centerRewardPool = 0;
                  updateCenterVisual();
                }
              }
            } else if (centralOwnerIndex === p.attackerIndex) {
              centralGarrison += p.sent;
            } else {
              const { attLeft, defLeft } = resolveBattle(p.sent, centralGarrison);
              if (attLeft > 0 && defLeft === 0) {
                centralOwnerIndex = p.attackerIndex; centralGarrison = attLeft;
                // Award dynamic pool to the captor
                if (centerRewardPool > 0) {
                  const award = Math.floor(centerRewardPool);
                  players[p.attackerIndex].gold += award;
                  centerRewardPool = 0;
                  updateCenterVisual();
                }
              }
              else { centralGarrison = defLeft; }
            }
            updateCenterVisual();
          }
        });
        return;
      }

      if (farmDecision.score > 0) {
        const sendFarm = farmDecision.amount;
        ai.army -= sendFarm;
        if (ai._armyByType) {
          const take = Math.min(sendFarm, ai._armyByType.militia || 0);
          ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
        }
        syncCastleGarrison(ai.index);
        sendTroops(ai.x, ai.y, farmTarget.fx, farmTarget.fy, null, {
          ownerIndex: ai.index,
          payload: { key: farmTarget.key, ownerIndex: ai.index, ownerLabel: ai.label, troops: sendFarm },
          onArrival: (p) => {
            const existing = farmOwners.get(p.key);
            if (existing && existing.ownerIndex !== p.ownerIndex) {
              const { attLeft, defLeft } = resolveBattle(p.troops, existing.troops);
              if (attLeft > 0) {
                farmOwners.set(p.key, { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: attLeft });
              } else {
                farmOwners.set(p.key, { ownerIndex: existing.ownerIndex, ownerLabel: existing.ownerLabel, troops: defLeft });
              }
            } else {
              const rec = existing || { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: 0 };
              rec.ownerIndex = p.ownerIndex; rec.ownerLabel = p.ownerLabel; rec.troops += p.troops;
              farmOwners.set(p.key, rec);
            }
            updateFarmVisual(p.key);
          }
        });
        return;
      }

      //    c) If farm not possible, try a castle raid vs rich & weak
      const raid = pickBestCastleRaid(ai);
      if (raid && ai.army > raid.def) {
        const needRaid = Math.min(ai.army, Math.max(1, raid.def + 1));
        const sendRaid = Math.max(1, Math.min(send, needRaid));
        ai.army -= sendRaid;
        if (ai._armyByType) {
          const take = Math.min(sendRaid, ai._armyByType.militia || 0);
          ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
        }
        syncCastleGarrison(ai.index);
        sendTroops(ai.x, ai.y, raid.cx, raid.cy, null, {
          ownerIndex: ai.index,
          payload: { key: `${raid.cx},${raid.cy}`, defenderIndex: raid.defenderIndex, sent: sendRaid, attackerIndex: ai.index, originX: ai.x, originY: ai.y, targetX: raid.cx, targetY: raid.cy },
          onArrival: (p) => {
            const defenderArmy = players[p.defenderIndex].army || 0;
            const { attLeft, defLeft } = resolveBattle(p.sent, defenderArmy);
            players[p.defenderIndex].army = defLeft;
            syncCastleGarrison(p.defenderIndex);
            if (attLeft > 0 && defLeft === 0) {
              const victim = players[p.defenderIndex];
              const loot = calcRandomLoot(victim.gold);
              victim.gold = Math.max(0, victim.gold - loot);
              players[ai.index].gold += loot;
              sendBackSurvivors(p.targetX, p.targetY, p.originX, p.originY, attLeft, ai.index);
            }
          }
        });
        return;
      }

      //    d) If none viable, and we can make a serious push on center (even if not urgent), try it
      if (canTakeCenter(ai, send)) {
        ai.army -= send;
        if (ai._armyByType) {
          const take = Math.min(send, ai._armyByType.militia || 0);
          ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
        }
        syncCastleGarrison(ai.index);
        sendTroops(ai.x, ai.y, 50, 50, null, {
          ownerIndex: ai.index,
          payload: { sent: send, attackerIndex: ai.index },
          onArrival: (p) => {
            if (centralOwnerIndex === null) {
              const before = centerDefense;
              const { attLeft, defLeft } = resolveBattle(p.sent, before);
              centerDefense = defLeft;
              grantCenterGuardReward(p.attackerIndex, before, centerDefense);
              if (attLeft > 0 && defLeft === 0) {
                centralOwnerIndex = p.attackerIndex; centralGarrison = attLeft;
                // Award dynamic pool to the captor
                if (centerRewardPool > 0) {
                  const award = Math.floor(centerRewardPool);
                  players[p.attackerIndex].gold += award;
                  centerRewardPool = 0;
                  updateCenterVisual();
                }
              }
            } else if (centralOwnerIndex === p.attackerIndex) {
              centralGarrison += p.sent;
            } else {
              const { attLeft, defLeft } = resolveBattle(p.sent, centralGarrison);
              if (attLeft > 0 && defLeft === 0) {
                centralOwnerIndex = p.attackerIndex; centralGarrison = attLeft;
                // Award dynamic pool to the captor
                if (centerRewardPool > 0) {
                  const award = Math.floor(centerRewardPool);
                  players[p.attackerIndex].gold += award;
                  centerRewardPool = 0;
                  updateCenterVisual();
                }
              }
              else { centralGarrison = defLeft; }
            }
            updateCenterVisual();
          }
        });
        return;
      }

      //    e) Otherwise, hold — let income/auto-hire stack for a stronger push next cycle
    }

    // Run AI for players 2..8 with jittered schedule (per profile)
    function scheduleAI(ai) {
      const prof = ai.aiProfile || { actionDelayMin: 6000, actionDelayMax: 12000 };
      const span = Math.max(0, (prof.actionDelayMax - prof.actionDelayMin));
      const delay = (prof.actionDelayMin || 6000) + Math.random() * span;
      setTimeout(() => {
        aiHireAndAct(ai);
        scheduleAI(ai); // reschedule with new jitter per profile
      }, delay);
    }
    for (let i = 1; i < players.length; i++) {
      scheduleAI(players[i]);
    }

    // Ensure initial sidebar render runs once at startup
    renderPlayerSidebar();
  </script>
</body>
</html>