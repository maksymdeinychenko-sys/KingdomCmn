<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Castle War Prototype</title>
  <style>
    body {
      margin: 0;
      background: #ade16a;
      font-family: sans-serif;
      overflow: hidden;
    }
    #game {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: url("bg.jpg") center/cover no-repeat;
      padding-bottom: 110px; /* bar(90) + 20px breathing room */
      box-sizing: border-box;
    }
    .object {
      position: absolute;
      transform: translate(-50%, -50%);
      cursor: pointer;
      text-align: center;
    }
    .object span {
      display: block;
      font-size: 10px;
      margin-top: 2px;
      color: white;
      text-shadow: 1px 1px 2px black;
    }
    .castle {
      width: 64px;
    }
    .mine {
      width: 48px;
    }
    .center {
      width: 72px;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 60;              /* above moving icons/lines */
      pointer-events: auto;     /* ensure clicks land */
    }
    #troop-panel {
      position: fixed;         /* detached from playfield */
      bottom: 0;
      left: 0;
      right: 0;
      height: 90px;            /* thinner bar */
      background: rgba(0,0,0,0.9); /* solid dark background */
      padding: 10px 16px;      /* inner spacing */
      color: #fff;
      font-size: 14px;
      display: flex;
      justify-content: space-around;
      align-items: center;
      gap: 20px;
      z-index: 40;             /* above map, below toasts */
      border-top: 1px solid rgba(255,255,255,0.15);
      backdrop-filter: blur(2px);
    }
    .troop-btn {
      background: #3a8;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    .local-player {
      border: 2px solid yellow;
      box-shadow: 0 0 10px yellow;
    }
    .army-icon {
      width: 24px;
      position: absolute;
      transition: all linear;
    }
    .mine.owned {
      /* visual marker for owned farms; color set inline via style */
      outline: 2px solid;
      outline-offset: 2px;
    }
    .castle.owned {
      outline: 2px solid;
      outline-offset: 2px;
    }
    .center.owned {
      outline: 2px solid;
      outline-offset: 2px;
    }
    .army-icon.bubble {
      border: 2px solid;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
      background: rgba(255,255,255,0.2);
    }
    .army-glyph {
      width: 14px;
      height: 14px;
      vertical-align: -2px;
      margin-right: 3px;
      image-rendering: pixelated;
    }
    #sidebar {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 20;
      width: 240px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border-radius: 8px;
      overflow: hidden;
      font-size: 14px;
    }
    #sidebar summary {
      cursor: pointer;
      list-style: none;
      padding: 10px 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(0,0,0,0.7);
    }
    #sidebar[open] summary {
      border-bottom: 1px solid rgba(255,255,255,0.15);
    }
    .player-list { padding: 8px 10px; max-height: 40vh; overflow: auto; }
    .player-row { display:flex; align-items:center; justify-content:space-between; padding:6px 4px; }
    .player-meta { display:flex; align-items:center; gap:8px; }
    .player-dot { width:10px; height:10px; border-radius:50%; outline:1px solid rgba(0,0,0,0.4); }
    .win-badge { 
      min-width: 18px; 
      text-align: center; 
      padding: 2px 4px; 
      margin-right: 6px; 
      border-radius: 4px; 
      background: rgba(255,215,0,0.18); 
      border: 1px solid rgba(255,215,0,0.55); 
      color: #ffd700; 
      font-weight: 700; 
      font-size: 12px; 
      font-variant-numeric: tabular-nums;
    }
    .player-gold { font-variant-numeric: tabular-nums; }
    .player-income { font-variant-numeric: tabular-nums; opacity: 0.9; }
    .player-row .cols { display:flex; align-items:center; gap:12px; }
    .player-income small { opacity: 0.75; font-size: 12px; margin-left: 2px; }
#toasts { position: absolute; bottom: 102px; right: 12px; z-index: 50; display: flex; flex-direction: column; gap: 8px; }
.toast { background: rgba(0,0,0,0.75); color:#fff; padding:8px 12px; border-radius:8px; font-size:13px; pointer-events:none; animation: fadeout 3s forwards; }
@keyframes fadeout { 0%{opacity:1; transform:translateY(0)} 80%{opacity:1} 100%{opacity:0; transform:translateY(10px)} }
    .tiny-btn { margin-left: 6px; padding: 2px 6px; font-size: 11px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.4); background: rgba(255,255,255,0.12); color: #fff; cursor: pointer; }
    .tiny-btn:hover { background: rgba(255,255,255,0.22); }
    .tiny-btn.on  { background: rgba(46,204,113,0.35); border-color: rgba(46,204,113,0.6); }
    .tiny-btn.off { background: rgba(255,255,255,0.12); border-color: rgba(255,255,255,0.35); opacity: 0.9; }
    .troop-slot { display:flex; flex-direction:column; align-items:center; gap:6px; min-width: 160px; }
    /* Make sure inputs inside #ui always receive clicks */
    #ui button, #ui select { pointer-events: auto; }
  </style>
</head>
<body>
  <div id="game">
    <div id="ui">
      <div>Timer: <span id="timer">10:00</span></div>
      <div>Gold: <span id="gold">500</span></div>
      <div>Army: <span id="army">0</span></div>
      <div>Farms: <span id="farms">0</span></div>
      <div>Income: <span id="income">60</span>/min <button id="toggle-net" class="tiny-btn">NET</button></div>
      <div><button id="toggle-autohire" class="tiny-btn on">Auto-hire: ON</button></div>
      <div style="margin-top:6px; display:flex; align-items:center; gap:8px;">
        <div>Game Speed: <span id="speed-label">x1</span></div>
        <input id="speed-slider" type="range" min="1" max="10" step="1" value="1" style="width:140px;" />
      </div>
      <div style="margin-top:6px; display:flex; align-items:center; gap:8px;">
        <div>Local AI:</div>
        <button id="toggle-local-ai" class="tiny-btn off">OFF</button>
        <select id="local-ai-profile" style="font-size:12px; padding:2px 4px; border-radius:6px;">
          <option value="Balanced">Balanced</option>
          <option value="Hoarder">Hoarder</option>
          <option value="Skirmisher">Skirmisher</option>
          <option value="Opportunist">Opportunist</option>
        </select>
      </div>
    </div>
    <details id="sidebar" open>
      <summary>
        Players & Gold
        <span style="opacity:.8;font-size:12px">(click to toggle)</span>
      </summary>
      <div class="player-list" id="player-list"></div>
    </details>
    <div id="troop-panel">
      <div class="troop-slot">
        <div class="troop-btn" onclick="hire('infantry', 50)">Hire Infantry (50)</div>
        <button id="toggle-autohire-infantry" class="tiny-btn on">Auto: ON</button>
      </div>
      <div class="troop-slot">
        <div class="troop-btn" onclick="hire('archer', 70)">Hire Archer (70)</div>
        <button id="toggle-autohire-archer" class="tiny-btn on">Auto: ON</button>
      </div>
      <div class="troop-slot">
        <div class="troop-btn" onclick="hire('cavalry', 100)">Hire Cavalry (100)</div>
        <button id="toggle-autohire-cavalry" class="tiny-btn on">Auto: ON</button>
      </div>
      <div class="troop-slot">
        <div class="troop-btn" onclick="hire('militia', 30)">Hire Militia (30)</div>
        <button id="toggle-autohire-militia" class="tiny-btn on">Auto: ON</button>
      </div>
    </div>
    <div id="toasts"></div>
  </div>

  <div id="modal-overlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);z-index:10;justify-content:center;align-items:center;">
    <div id="modal" style="background:white;padding:20px;border-radius:10px;min-width:200px;text-align:center;"></div>
  </div>

  <script>
    const farmsMap = new Map();
    const capturedFarms = new Set();
    const farmOwners = new Map(); // key -> { ownerIndex, ownerLabel, troops }
    const farmElements = new Map(); // key -> DOM element for the farm
    const playerColors = ['#ffd700', '#00bfff', '#ff4500', '#32cd32', '#ff69b4', '#ffa500', '#8a2be2', '#00ced1'];
    const castleElements = new Map(); // key -> DOM element for castle

    // --- Auto-hiring (per minute) rates ---
    const autoHireRatesPerMin = {
      militia: 0.50,
      infantry: 0.80,
      archer: 0.5,
      cavalry: 1.00,
    };

    // --- Full unit purchase costs (used by auto-hire when buying) ---
    const unitCosts = {
      infantry: 50,
      archer: 70,
      cavalry: 100,
      militia: 30,
    };

    // --- Loot & targeting tuning ---
    const LOOT_MIN_PCT = 0.05;   // 5%
    const LOOT_MAX_PCT = 0.30;   // 30%
    const RICH_GOLD_THRESHOLD = 600; // when an opponent is "rich", bots will also harass their farms

    // Raids should target only reasonably rich opponents; otherwise prefer farms/defense
    const RAID_MIN_TARGET_GOLD = 200; // skip castle raids if defender has less gold than this

    // If a bot can inflict >=1% damage to the central castle this push, use this base chance to prefer a center push
    const CENTER_ONEPUSH_CHANCE = 0.85; // 85% base chance (bots value center more)
    // Limit for aggressive farm sweeps: only nearby weak farms (board is 0..100)
    const SWEEP_MAX_RADIUS = 35; // percent units; ~35% of board width

    function calcRandomLoot(amount) {
      const pct = LOOT_MIN_PCT + Math.random() * (LOOT_MAX_PCT - LOOT_MIN_PCT);
      return Math.max(1, Math.floor(amount * pct));
    }

    // Central Castle ownership model
    let centerDefenseMax = 333;         // maximum neutral defenders
    let centerDefense = centerDefenseMax; // current neutral defenders until captured
    let centralOwnerIndex = null;        // null => neutral
    let centralGarrison = 0;             // troops stationed if owned
    let centerElement = null;            // DOM element reference
    // Track per-attacker reward progress for neutral guard damage (percentage thresholds)
    const centerDamageProgress = new Map(); // attackerIndex -> last whole percent rewarded
    // Dynamic reward pool for attacking/capturing the center
    const CENTER_POOL_RATE_PER_MIN = 200; // how fast the pool grows while neutral (gold per minute)
    const CENTER_POOL_START = 20000;          // starting pool when neutral at game start
    let centerRewardPool = CENTER_POOL_START; // current pool
    let _centerPoolAcc = 0;               // small accumulator for throttling UI refresh

    // Reward per 1% neutral guard destroyed (tunable)
    const CENTER_REWARD_PER_PERCENT = 300;

    function updateCenterVisual() {
      if (!centerElement) return;
      const span = centerElement.querySelector('span');
      if (centralOwnerIndex === null) {
        if (span) span.innerHTML = `Central Castle — Guard: <img src="army-icon.png" class="army-glyph">${centerDefense} — Pool: ${Math.floor(centerRewardPool)}`;
        centerElement.classList.remove('owned');
        centerElement.style.outlineColor = '';
      } else {
        const color = playerColors[centralOwnerIndex % playerColors.length] || '#fff';
        centerElement.classList.add('owned');
        centerElement.style.outlineColor = color;
        if (span) span.innerHTML = `Central Castle — Owner: Player ${centralOwnerIndex + 1} — Garrison: <img src="army-icon.png" class="army-glyph">${centralGarrison}`;
      }
    }

    function updateFarmVisual(key) {
      const el = farmElements.get(key);
      if (!el) return;
      const span = el.querySelector('span');
      const rec = farmOwners.get(key);
      if (rec) {
        if (span) span.innerHTML = `Farm — ${rec.ownerLabel}: <img src="army-icon.png" class="army-glyph">${rec.troops}`;
        el.classList.add('owned');
        const color = playerColors[rec.ownerIndex % playerColors.length] || '#fff';
        el.style.outlineColor = color;
      } else {
        if (span) span.textContent = 'Farm';
        el.classList.remove('owned');
        el.style.outlineColor = '';
      }
    }

    // Safe playfield bounds so objects don't sit under the bottom HUD
    const SAFE_MIN_Y = 6;   // small top margin
    const SAFE_MAX_Y = 82;  // keep bottom clear of the 90px HUD

    // --- Players / Ownership model ---
    const positionsRaw = [
      [20, 10], [50, 10], [80, 20], [90, 50],
      [80, 80], [50, 90], [20, 80], [10, 50],
    ];
    const positions = positionsRaw.map(([x, y]) => [x, Math.min(Math.max(y, SAFE_MIN_Y), SAFE_MAX_Y)]);
    const players = positions.map(([x, y], i) => ({
      index: i,
      label: `Player ${i + 1}`,
      x, y,
      gold: 500,
      army: 0,
    }));

    // Wins tracking (per session; persisted via localStorage)
    players.forEach(p => { p.wins = 0; });
    try {
      const savedWins = localStorage.getItem('playerWins');
      if (savedWins) {
        const arr = JSON.parse(savedWins);
        arr.forEach((w, idx) => { if (players[idx]) players[idx].wins = Number(w) || 0; });
      }
    } catch {}

    // Ensure each player has per-type army buckets
    players.forEach((p) => {
      if (!p._armyByType) p._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
    });

    // --- AI Strategy Profiles ---
    function createAIProfile() {
      const roll = Math.random();
      if (roll < 0.25) {
        // Hoarder:
        return {
          name: 'Hoarder',
          actionDelayMin: 9000,
          actionDelayMax: 14000,
          sendFracMin: 0.20,
          sendFracMax: 0.40,
          urgentBoost: 1.4,
          recallChance: 0.45,
          recallThreshold: 8,
          recallMaxFarms: 3,
          centerAggression: 1.2,
          farmBias: 1.0,
          raidBias: 0.9,
          centerPushChance: 0.65,
          percentDecisionChance: 0.80,
          sendPercentMin: 0.25,
          sendPercentMax: 0.50,
          keepBackMin: 0.30,
          multiActCap: 2,
          sweepMaxTargets: 2
        };
      } else if (roll < 0.5) {
        // Skirmisher:
        return {
          name: 'Skirmisher',
          actionDelayMin: 4000,
          actionDelayMax: 7000,
          sendFracMin: 0.15,
          sendFracMax: 0.35,
          urgentBoost: 1.2,
          recallChance: 0.20,
          recallThreshold: 6,
          recallMaxFarms: 1,
          centerAggression: 1.0,
          farmBias: 1.2,
          raidBias: 1.1,
          centerPushChance: 0.55,
          percentDecisionChance: 0.50,
          sendPercentMin: 0.10,
          sendPercentMax: 0.30,
          keepBackMin: 0.15,
          multiActCap: 3,
          sweepMaxTargets: 3
        };
      } else if (roll < 0.75) {
        // Opportunist:
        return {
          name: 'Opportunist',
          actionDelayMin: 6000,
          actionDelayMax: 10000,
          sendFracMin: 0.25,
          sendFracMax: 0.50,
          urgentBoost: 1.3,
          recallChance: 0.30,
          recallThreshold: 7,
          recallMaxFarms: 2,
          centerAggression: 1.5,
          farmBias: 1.1,
          raidBias: 1.0,
          centerPushChance: 0.85,
          percentDecisionChance: 0.70,
          sendPercentMin: 0.20,
          sendPercentMax: 0.45,
          keepBackMin: 0.25,
          multiActCap: 3,
          sweepMaxTargets: 3
        };
      }
      // Balanced (fallback)
      return {
        name: 'Balanced',
        actionDelayMin: 6000,
        actionDelayMax: 12000,
        sendFracMin: 0.25,
        sendFracMax: 0.35,
        urgentBoost: 1.2,
        recallChance: 0.25,
        recallThreshold: 8,
        recallMaxFarms: 2,
        centerAggression: 1.2,
        farmBias: 1.0,
        raidBias: 1.0,
        centerPushChance: 0.7,
        percentDecisionChance: 0.60,
        sendPercentMin: 0.15,
        sendPercentMax: 0.40,
        keepBackMin: 0.20,
        multiActCap: 2,
        sweepMaxTargets: 2
      };
    }

    // --- AI Profile factory by name ---
    function createAIProfileByName(name) {
      switch ((name || '').toLowerCase()) {
        case 'hoarder':
          return {
            name: 'Hoarder',
            actionDelayMin: 9000,
            actionDelayMax: 14000,
            sendFracMin: 0.20,
            sendFracMax: 0.40,
            urgentBoost: 1.4,
            recallChance: 0.45,
            recallThreshold: 8,
            recallMaxFarms: 3,
            centerAggression: 1.2,
            farmBias: 1.0,
            raidBias: 0.9,
            centerPushChance: 0.65,
            percentDecisionChance: 0.80,
            sendPercentMin: 0.25,
            sendPercentMax: 0.50,
            keepBackMin: 0.30,
            multiActCap: 2,
            sweepMaxTargets: 2
          };
        case 'skirmisher':
          return {
            name: 'Skirmisher',
            actionDelayMin: 4000,
            actionDelayMax: 7000,
            sendFracMin: 0.15,
            sendFracMax: 0.35,
            urgentBoost: 1.2,
            recallChance: 0.20,
            recallThreshold: 6,
            recallMaxFarms: 1,
            centerAggression: 1.0,
            farmBias: 1.2,
            raidBias: 1.1,
            centerPushChance: 0.55,
            percentDecisionChance: 0.50,
            sendPercentMin: 0.10,
            sendPercentMax: 0.30,
            keepBackMin: 0.15,
            multiActCap: 3,
            sweepMaxTargets: 3
          };
        case 'opportunist':
          return {
            name: 'Opportunist',
            actionDelayMin: 6000,
            actionDelayMax: 10000,
            sendFracMin: 0.25,
            sendFracMax: 0.50,
            urgentBoost: 1.3,
            recallChance: 0.30,
            recallThreshold: 7,
            recallMaxFarms: 2,
            centerAggression: 1.5,
            farmBias: 1.1,
            raidBias: 1.0,
            centerPushChance: 0.85,
            percentDecisionChance: 0.70,
            sendPercentMin: 0.20,
            sendPercentMax: 0.45,
            keepBackMin: 0.25,
            multiActCap: 3,
            sweepMaxTargets: 3
          };
        default:
          return {
            name: 'Balanced',
            actionDelayMin: 6000,
            actionDelayMax: 12000,
            sendFracMin: 0.25,
            sendFracMax: 0.35,
            urgentBoost: 1.2,
            recallChance: 0.25,
            recallThreshold: 8,
            recallMaxFarms: 2,
            centerAggression: 1.2,
            farmBias: 1.0,
            raidBias: 1.0,
            centerPushChance: 0.7,
            percentDecisionChance: 0.60,
            sendPercentMin: 0.15,
            sendPercentMax: 0.40,
            keepBackMin: 0.20,
            multiActCap: 2,
            sweepMaxTargets: 2
          };
      }
    }

    // Assign a random profile to every bot (players 2..8)
    for (let i = 1; i < players.length; i++) {
      players[i].aiProfile = createAIProfile();
    }

    // Castle garrisons: key -> { ownerIndex, troops }
    const castleGarrisons = new Map();
    positions.forEach(([x, y], i) => {
      const key = `${x},${y}`;
      castleGarrisons.set(key, { ownerIndex: i, troops: 0 });
    });

    // Helper: resolve simple 1:1 attrition battle
    function resolveBattle(attacker, defender) {
      const attLeft = Math.max(0, attacker - defender);
      const defLeft = Math.max(0, defender - attacker);
      return { attLeft, defLeft };
    }

    // Reward helper: grant gold for each whole percent of neutral guard destroyed
    function grantCenterGuardReward(attackerIndex, beforeDef, afterDef) {
      if (attackerIndex == null) return;
      // Only while center is neutral (no owner)
      if (centralOwnerIndex !== null) return;
      const prevPct = Math.floor(((centerDefenseMax - beforeDef) / centerDefenseMax) * 100);
      const newPct  = Math.floor(((centerDefenseMax - afterDef)  / centerDefenseMax) * 100);
      if (newPct > prevPct) {
        let steps = newPct - prevPct; // how many whole percents crossed this strike
        const p = players[attackerIndex];
        let totalAward = 0;
        while (steps-- > 0) {
          const stepAward = Math.max(0, Math.floor(centerRewardPool * 0.01)); // 1% of CURRENT pool
          if (stepAward > 0) {
            totalAward += stepAward;
            centerRewardPool = Math.max(0, centerRewardPool - stepAward);
          }
        }
        if (totalAward > 0) {
          p.gold += totalAward;
          if (attackerIndex === 0) {
            gold = p.gold; goldText.textContent = Math.floor(gold);
            showToast(`+${totalAward} gold (center damage)`);
          }
          updateCenterVisual();
        }
      }
      // Record latest awarded percent for this attacker
      centerDamageProgress.set(attackerIndex, newPct);
    }

    // Helper: count farms owned by a player
    function countFarmsOwned(ownerIndex) {
      let n = 0;
      farmOwners.forEach((rec) => { if (rec.ownerIndex === ownerIndex) n++; });
      return n;
    }

    // Estimate expected auto-hire spend per minute using per-type army structure (floored for UI)
    function estimateAutoHireCostPerMin(player) {
      if (!player) return 0;
      if (!player._armyByType) player._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      let spend = 0;
      for (const [type, rate] of Object.entries(autoHireRatesPerMin)) {
        const qty = player._armyByType[type] || 0;
        spend += rate * qty;
      }
      // For UI: always floor to integer
      return Math.floor(spend);
    }

    // Raw upkeep per minute (no flooring) for simulation logic (precise)
    function upkeepPerMinRaw(player) {
      if (!player) return 0;
      if (!player._armyByType) player._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      let sum = 0;
      for (const [type, rate] of Object.entries(autoHireRatesPerMin)) {
        const qty = player._armyByType[type] || 0;
        sum += rate * qty;
      }
      return sum;
    }

    // Calculate gross, upkeep, and net income per minute for a player
    function calculateNetIncome(player) {
      const farmsOwned = countFarmsOwned(player.index);
      const hasCenter = (centralOwnerIndex === player.index) ? 200 : 0;
      const grossIncome = 60 + farmsOwned * 30 + hasCenter;
      const totalUpkeep = upkeepPerMinRaw(player);
      const netIncome = grossIncome - totalUpkeep;
      player.grossIncome = grossIncome;
      player.totalUpkeep = totalUpkeep;
      player.netIncome = netIncome;
      return netIncome;
    }

    function fmtTime(s) {
      s = Math.max(0, Math.floor(s));
      const m = Math.floor(s / 60);
      const r = s % 60;
      return `${m.toString().padStart(2,'0')}:${r.toString().padStart(2,'0')}`;
    }

    function endMatch() {
      if (matchEnded) return;
      matchEnded = true;
      // winner by current gold
      const winner = [...players].sort((a,b)=> b.gold - a.gold)[0];
      // increment wins and persist
      if (winner && typeof winner.index === 'number') {
        players[winner.index].wins = (players[winner.index].wins || 0) + 1;
        try { localStorage.setItem('playerWins', JSON.stringify(players.map(p => p.wins || 0))); } catch {}
      }
      // refresh sidebar to show updated badges
      renderPlayerSidebar();
      const container = document.createElement('div');
      container.innerHTML = `
        <h3>Time's up!</h3>
        <div style="margin:8px 0;">Winner: <strong>${winner.label}</strong> (${winner.gold} gold)</div>
      `;
      const btnContinue = document.createElement('button');
      btnContinue.textContent = 'Continue';
      btnContinue.onclick = () => { closeModal(); matchTimeLeft = 600; matchEnded = false; };
      const btnNew = document.createElement('button');
      btnNew.textContent = 'New Game';
      btnNew.style.marginLeft = '10px';
      btnNew.onclick = () => { closeModal(); newGame(); };
      container.append(btnContinue, btnNew);
      showModal(container);
    }

    function newGame() {
      // reset players
      players.forEach((p) => { p.gold = 500; p.army = 0; p._goldAcc = 0; });
      gold = players[0].gold; army = players[0].army;
      goldText.textContent = Math.floor(gold); armyText.textContent = army;

      // reset farms
      farmOwners.clear();
      farmElements.forEach((_, key) => updateFarmVisual(key));
      capturedFarms.clear();
      const lf = countFarmsOwned(0);
      farmsText.textContent = lf;
      incomeText.textContent = 30 + lf * 10 + (centralOwnerIndex === 0 ? 200 : 0);

      // reset central castle
      centerDefense = centerDefenseMax;
      centralOwnerIndex = null;
      centralGarrison = 0;
      centerDamageProgress.clear();
      updateCenterVisual();
      // reset dynamic center reward pool
      centerRewardPool = CENTER_POOL_START;
      _centerPoolAcc = 0;
      updateCenterVisual();

      // sync castles
      for (let i = 0; i < players.length; i++) syncCastleGarrison(i);
      positions.forEach(([x, y]) => updateCastleVisual(`${x},${y}`));

      // reset timer
      matchTimeLeft = 600;
      matchEnded = false;

      // refresh sidebar
      renderPlayerSidebar();
    }

    // Helper: send surviving attackers back to their home castle and add to available army (not garrison)
    function sendBackSurvivors(fromX, fromY, toX, toY, survivors, ownerIndex) {
      if (!survivors || survivors <= 0) return;
      sendTroops(fromX, fromY, toX, toY, null, {
        ownerIndex,
        onArrival: () => {
          // Add survivors to the player's available army pool
          players[ownerIndex].army = (players[ownerIndex].army || 0) + survivors;
          // PART 1.3.5: Attribute survivors to militia bucket
          ensureArmyBuckets(players[ownerIndex]);
          players[ownerIndex]._armyByType.militia += survivors;
          if (ownerIndex === 0) {
            army += survivors;
            armyText.textContent = army;
          }
          syncCastleGarrison(ownerIndex);
        }
      });
    }

    // Keep each player's castle garrison equal to their available army
    function syncCastleGarrison(playerIndex) {
      const [cx, cy] = positions[playerIndex];
      const ckey = `${cx},${cy}`;
      const rec = { ownerIndex: playerIndex, troops: players[playerIndex].army || 0 };
      castleGarrisons.set(ckey, rec);
      updateCastleVisual(ckey);
    }

    // Auto-hire one unit per type if player has enough gold for that type (spends full price per unit)
    function autoHireArmy(player) {
      if (!player) return;
      // Human player's auto-hire can be toggled via UI; AI ignores this flag
      if (player.index === 0 && !autoHireEnabled) return;
      if (!player._armyByType) player._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      let _spent = 0;
      const _added = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      for (const type of Object.keys(unitCosts)) {
        const price = unitCosts[type];
        if ((player.index !== 0 || autoHireTypeEnabled[type]) && player.gold >= price) {
          player.gold -= price;
          player._armyByType[type] += 1;
          player.army = (player.army || 0) + 1;
          syncCastleGarrison(player.index);
          _spent += price;
          _added[type] += 1;
          // Update local UI if it's the human player
          if (player.index === 0) {
            gold = player.gold;
            goldText.textContent = Math.floor(gold);
            army = player.army;
            armyText.textContent = army;
            syncCastleGarrison(0);
          }
        }
      }
      // Show summary toast for local player if anything was hired
      if (player.index === 0 && _spent > 0) {
        const parts = [];
        for (const t of Object.keys(_added)) {
          if (_added[t] > 0) parts.push(`+${_added[t]} ${t}`);
        }
        if (parts.length) showToast(`Auto-hire: ${parts.join(', ')} (-${_spent} gold)`);
      }
    }

    // --- Income toggle ---
    let _showNet = true; // NET by default; toggle switches between NET and GROSS

    // --- Auto-hire toggle (persisted) ---
    let autoHireEnabled = true;
    try {
      const savedAuto = localStorage.getItem('autoHireEnabled');
      if (savedAuto !== null) autoHireEnabled = JSON.parse(savedAuto);
    } catch {}

    // --- Auto-hire per-type toggles (persisted) ---
    let autoHireTypeEnabled = { militia: true, infantry: true, archer: true, cavalry: true };
    try {
      const savedTypes = localStorage.getItem('autoHireTypeEnabled');
      if (savedTypes) {
        const parsed = JSON.parse(savedTypes);
        autoHireTypeEnabled = { ...autoHireTypeEnabled, ...parsed };
      }
    } catch {}

    // Continuous per-second income with upkeep applied to gold (using net income)
    players.forEach(p => p._goldAcc = 0);
    let _lastTs = performance.now();
    let _autoHireAcc = 0; // seconds accumulator for auto-hiring per minute
    function mainLoop(ts) {
      const dt = Math.max(0, (ts - _lastTs) / 1000) * Math.max(1, gameSpeed);
      _lastTs = ts;
      // Per-player income accumulation (net income: gross - upkeep)
      players.forEach((p) => {
        // Recalculate incomes and upkeep before gold is added
        calculateNetIncome(p);
        // Apply net income (can be negative)
        const netIncomePerSec = p.netIncome / 60;
        p._goldAcc += netIncomePerSec * dt;
        // Integer gold payout
        if (p._goldAcc >= 1 || p._goldAcc <= -1) {
          const whole = p._goldAcc > 0 ? Math.floor(p._goldAcc) : Math.ceil(p._goldAcc);
          p._goldAcc -= whole;
          p.gold += whole;
          if (p.index === 0) {
            gold = p.gold;
            goldText.textContent = Math.floor(gold);
          }
        }
        // Update local player UI
        if (p.index === 0) {
          const farmsOwned = countFarmsOwned(0);
          farmsText.textContent = farmsOwned;
          const gross = p.grossIncome;
          const expense = p.totalUpkeep;
          const incomeVal = _showNet ? Math.floor(gross - expense) : Math.floor(gross);
          incomeText.textContent = incomeVal;
        }
      });
      // Center reward pool accumulation (per second). When owned, pool stops growing and owner income is already accounted for in per-minute income (hasCenter +200)
      _centerPoolAcc += dt;
      const perSecPool = CENTER_POOL_RATE_PER_MIN / 60;
      if (centralOwnerIndex === null) {
        centerRewardPool += perSecPool * dt;
        // Throttle pool text updates to ~2Hz to avoid layout thrash
        if (_centerPoolAcc >= 0.5) { updateCenterVisual(); _centerPoolAcc = 0; }
      } else {
        // When owned, pool stops growing and owner income is already accounted for in per-minute income (hasCenter +200)
        _centerPoolAcc = 0; // no UI updates for pool when owned
      }
      // Auto-hiring update (run once per minute, catch up if tab was inactive)
      _autoHireAcc += dt;
      if (_autoHireAcc >= 60) {
        const ticks = Math.floor(_autoHireAcc / 60);
        _autoHireAcc -= ticks * 60;
        for (let i = 0; i < ticks; i++) {
          players.forEach((p) => autoHireArmy(p));
        }
      }
      // Match timer update
      if (!matchEnded) {
        matchTimeLeft -= dt;
        if (timerEl) timerEl.textContent = fmtTime(matchTimeLeft);
        if (matchTimeLeft <= 0) {
          endMatch();
        }
      }
      // Throttled sidebar refresh (~2 times/sec)
      mainLoop._acc = (mainLoop._acc || 0) + dt;
      if (mainLoop._acc >= 0.5) { renderPlayerSidebar(); mainLoop._acc = 0; }
      requestAnimationFrame(mainLoop);
    }
    requestAnimationFrame(mainLoop);
    const game = document.getElementById("game");
    const goldText = document.getElementById("gold");
    const armyText = document.getElementById("army");
    const farmsText = document.getElementById("farms");
    const incomeText = document.getElementById("income");
    const timerEl = document.getElementById('timer');
    const toggleNetBtn = document.getElementById('toggle-net');
    if (toggleNetBtn) {
      toggleNetBtn.onclick = () => {
        _showNet = !_showNet;
        toggleNetBtn.textContent = _showNet ? 'NET' : 'GROSS';
        // Refresh HUD income immediately
        const farmsOwned = countFarmsOwned(0);
        const gross = 60 + farmsOwned * 30 + (centralOwnerIndex === 0 ? 200 : 0);
        const expense = estimateAutoHireCostPerMin(players[0]);
        const incomeVal = _showNet ? Math.max(0, Math.floor(gross - expense)) : Math.floor(gross);
        incomeText.textContent = incomeVal;
        // Refresh sidebar
        renderPlayerSidebar();
      };
    }

    // --- Game Speed (x1..x10) ---
    let gameSpeed = 1;
    try {
      const savedGS = localStorage.getItem('gameSpeed');
      if (savedGS !== null) gameSpeed = Math.min(10, Math.max(1, parseInt(savedGS)));
    } catch {}

    const speedSlider = document.getElementById('speed-slider');
    const speedLabel  = document.getElementById('speed-label');
    function refreshSpeedUI() {
      if (speedLabel) speedLabel.textContent = `x${gameSpeed}`;
      if (speedSlider) speedSlider.value = String(gameSpeed);
    }
    refreshSpeedUI();


    if (speedSlider) {
      speedSlider.oninput = () => {
        const v = parseInt(speedSlider.value);
        gameSpeed = Math.min(10, Math.max(1, v));
        refreshSpeedUI();
        try { localStorage.setItem('gameSpeed', String(gameSpeed)); } catch {}
        showToast(`Speed: x${gameSpeed}`);
      };
    }

    // --- Local AI control (player 0) ---
    const toggleLocalAIButton = document.getElementById('toggle-local-ai');
    const localAIProfileSelect = document.getElementById('local-ai-profile');
    let localAIEnabled = false;

    // Restore saved state
    try {
      const savedLocalAI = localStorage.getItem('localAIEnabled');
      const savedProfile = localStorage.getItem('localAIProfileName');
      if (savedProfile && localAIProfileSelect) localAIProfileSelect.value = savedProfile;
      if (savedLocalAI !== null) localAIEnabled = JSON.parse(savedLocalAI);
    } catch {}

    function refreshLocalAIUI() {
      if (!toggleLocalAIButton) return;
      toggleLocalAIButton.textContent = localAIEnabled ? 'ON' : 'OFF';
      toggleLocalAIButton.classList.remove('on','off');
      toggleLocalAIButton.classList.add(localAIEnabled ? 'on' : 'off');
      toggleLocalAIButton.title = localAIEnabled ? 'Local player is AI-controlled' : 'Local player is human-controlled';
    }
    refreshLocalAIUI();

    function applyLocalAIProfile() {
      const name = localAIProfileSelect ? localAIProfileSelect.value : 'Balanced';
      players[0].aiProfile = createAIProfileByName(name);
      try { localStorage.setItem('localAIProfileName', name); } catch {}
    }

    if (localAIProfileSelect) {
      localAIProfileSelect.addEventListener('change', () => {
        applyLocalAIProfile();
        if (localAIEnabled) { if (players[0]._aiTimerId) clearTimeout(players[0]._aiTimerId); scheduleAI(players[0]); }
        showToast(`Local AI profile: ${localAIProfileSelect.value}`);
      }, { passive: true });
    }

    if (toggleLocalAIButton) {
      toggleLocalAIButton.addEventListener('click', (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        localAIEnabled = !localAIEnabled;
        try { localStorage.setItem('localAIEnabled', JSON.stringify(localAIEnabled)); } catch {}
        refreshLocalAIUI();
        if (localAIEnabled) {
          applyLocalAIProfile();
          scheduleAI(players[0]);
          showToast('Local AI enabled');
        } else {
          if (players[0]._aiTimerId) { clearTimeout(players[0]._aiTimerId); players[0]._aiTimerId = null; }
          showToast('Local AI disabled');
        }
      }, { passive: true });
    }

    // If enabled from previous session, start immediately
    if (localAIEnabled) { applyLocalAIProfile(); scheduleAI(players[0]); }

    const toggleAutoBtn = document.getElementById('toggle-autohire');
    function refreshAutoHireBtn() {
      if (!toggleAutoBtn) return;
      toggleAutoBtn.textContent = autoHireEnabled ? 'Auto-hire: ON' : 'Auto-hire: OFF';
      toggleAutoBtn.classList.remove('on','off');
      toggleAutoBtn.classList.add(autoHireEnabled ? 'on' : 'off');
      toggleAutoBtn.title = autoHireEnabled ? 'Automatic hiring is enabled' : 'Automatic hiring is disabled';
    }
    refreshAutoHireBtn();
    if (toggleAutoBtn) {
      toggleAutoBtn.onclick = () => {
        autoHireEnabled = !autoHireEnabled;
        try { localStorage.setItem('autoHireEnabled', JSON.stringify(autoHireEnabled)); } catch {}
        refreshAutoHireBtn();
        showToast(autoHireEnabled ? 'Auto-hire enabled' : 'Auto-hire disabled');
      };
    }

    // --- Auto-hire per-type button wiring and state ---
    const perTypeBtns = {
      militia: document.getElementById('toggle-autohire-militia'),
      infantry: document.getElementById('toggle-autohire-infantry'),
      archer: document.getElementById('toggle-autohire-archer'),
      cavalry: document.getElementById('toggle-autohire-cavalry'),
    };

    function refreshPerTypeBtns() {
      for (const t of Object.keys(perTypeBtns)) {
        const btn = perTypeBtns[t];
        if (!btn) continue;
        const on = !!autoHireTypeEnabled[t];
        btn.textContent = `${t.charAt(0).toUpperCase()+t.slice(1)}: ${on ? 'ON' : 'OFF'}`;
        btn.classList.remove('on','off');
        btn.classList.add(on ? 'on' : 'off');
        btn.title = on ? `Auto-hire ${t} is enabled` : `Auto-hire ${t} is disabled`;
      }
    }
    refreshPerTypeBtns();

    for (const t of Object.keys(perTypeBtns)) {
      const btn = perTypeBtns[t];
      if (!btn) continue;
      btn.onclick = () => {
        autoHireTypeEnabled[t] = !autoHireTypeEnabled[t];
        try { localStorage.setItem('autoHireTypeEnabled', JSON.stringify(autoHireTypeEnabled)); } catch {}
        refreshPerTypeBtns();
        showToast(`${t} auto-hire ${autoHireTypeEnabled[t] ? 'enabled' : 'disabled'}`);
      };
    }
    let matchTimeLeft = 600; // 10 minutes
    let matchEnded = false;
    let gold = 500;
    let army = 0;

    // Sidebar DOM refs and render
    const playerListEl = document.getElementById('player-list');

    function getTotalTroops(ownerIndex) {
      let total = 0;
      // idle troops (purchased but not sent)
      total += players[ownerIndex].army || 0;
      // castle garrison
      const ckey = `${positions[ownerIndex][0]},${positions[ownerIndex][1]}`;
      const cg = castleGarrisons.get(ckey);
      if (cg && cg.ownerIndex === ownerIndex) total += cg.troops;
      // farms
      farmOwners.forEach((rec) => { if (rec.ownerIndex === ownerIndex) total += rec.troops; });
      return total;
    }

    function renderPlayerSidebar() {
      if (!playerListEl) return;
      const frag = document.createDocumentFragment();
      [...players].sort((a,b)=> b.gold - a.gold).forEach((p) => {
        // Ensure incomes are up-to-date (in case not updated this frame)
        calculateNetIncome(p);
        const row = document.createElement('div');
        row.className = 'player-row';

        // left: win badge + color dot + name
        const meta = document.createElement('div');
        meta.className = 'player-meta';
        const win = document.createElement('div');
        win.className = 'win-badge';
        // show empty until first win to match design request
        win.textContent = (p.wins && p.wins > 0) ? String(p.wins) : '';
        win.title = (p.wins && p.wins > 0) ? `${p.wins} wins` : 'No wins yet';
        const dot = document.createElement('div');
        dot.className = 'player-dot';
        dot.style.background = playerColors[p.index % playerColors.length] || '#fff';
        const name = document.createElement('div');
        name.textContent = p.label;
        meta.append(win, dot, name);

        // middle: live income per minute (net: gross income minus auto-hire estimate)
        const gross = p.grossIncome || 0;
        const expense = p.totalUpkeep || 0;
        // For UI: always floor net income (down), and do not display negative values
        const net = Math.floor(gross - expense);
        const incomeVal = _showNet ? Math.max(0, net) : Math.floor(gross);
        const incomeEl = document.createElement('div');
        incomeEl.className = 'player-income';
        incomeEl.innerHTML = `${incomeVal}<small>/min</small>`;
        incomeEl.title = _showNet
          ? `Income: ${Math.floor(gross)}/min\nUpkeep: -${Math.floor(expense)}/min\nNet: ${net}/min`
          : `Gross income: ${Math.floor(gross)}/min`;

        // right: current gold
        const goldEl = document.createElement('div');
        goldEl.className = 'player-gold';
        goldEl.textContent = `${Math.floor(p.gold)}`;

        const cols = document.createElement('div');
        cols.className = 'cols';
        cols.append(incomeEl, goldEl);

        row.append(meta, cols);
        frag.appendChild(row);
      });
      playerListEl.innerHTML = '';
      playerListEl.appendChild(frag);
    }

    function showModal(content) {
      const modal = document.getElementById("modal");
      modal.innerHTML = '';
      modal.appendChild(content);
      document.getElementById("modal-overlay").style.display = "flex";
    }

    function closeModal() {
      document.getElementById("modal-overlay").style.display = "none";
    }

    function createInputPopup(title, maxAmount, callback) {
      const container = document.createElement("div");
      const titleElem = document.createElement("div");
      titleElem.textContent = title;
      titleElem.style.marginBottom = "10px";
      const input = document.createElement("input");
      input.type = "number";
      input.value = "1";
      input.min = "1";
      input.max = maxAmount;
      input.style.width = "100%";
      input.style.marginBottom = "10px";

      const ok = document.createElement("button");
      ok.textContent = "OK";
      const cancel = document.createElement("button");
      cancel.textContent = "Cancel";
      cancel.style.marginLeft = "10px";

      function validate() {
        ok.disabled = parseInt(input.value) > maxAmount || parseInt(input.value) < 1;
      }

      input.oninput = validate;
      validate();

      ok.onclick = () => {
        callback(parseInt(input.value));
        closeModal();
      };
      cancel.onclick = closeModal;

      container.append(titleElem, input, ok, cancel);
      showModal(container);
    }

    function createInfoPopup(message) {
      const container = document.createElement("div");
      container.innerHTML = `<div style='margin-bottom:10px;'>${message}</div>`;
      const btn = document.createElement("button");
      btn.textContent = "OK";
      btn.onclick = closeModal;
      container.appendChild(btn);
      showModal(container);
    }

    function showToast(message) {
      const c = document.getElementById('toasts');
      if (!c) return;
      const el = document.createElement('div');
      el.className = 'toast';
      el.textContent = message;
      c.appendChild(el);
      setTimeout(() => { if (el.parentNode === c) c.removeChild(el); }, 3000);
    }

    function createTroopPopup(troopTypes, maxAmounts, callback) {
      const container = document.createElement("div");
      container.innerHTML = "<h3>Select Troops</h3>";
      const troopInputs = {};

      troopTypes.forEach((type) => {
        const div = document.createElement("div");
        div.textContent = `${type}: `;
        const input = document.createElement("input");
        input.type = "number";
        input.value = "0";
        input.min = "0";
        input.max = maxAmounts[type];
        input.style.marginLeft = "5px";
        div.appendChild(input);
        container.appendChild(div);
        troopInputs[type] = input;
      });

      const ok = document.createElement("button");
      ok.textContent = "OK";
      const cancel = document.createElement("button");
      cancel.textContent = "Cancel";
      cancel.style.marginLeft = "10px";

      ok.onclick = () => {
        const selected = {};
        let totalSelected = 0;
        Object.keys(troopInputs).forEach((type) => {
          const amount = parseInt(troopInputs[type].value);
          if (amount > 0) {
            selected[type] = amount;
            totalSelected += amount;
          }
        });
        callback(selected, totalSelected);
        closeModal();
      };

      cancel.onclick = closeModal;
      container.append(ok, cancel);
      showModal(container);
    }

    // === Per-type army helpers (1.3.1) ===
    function ensureArmyBuckets(p) {
      if (!p._armyByType) p._armyByType = { militia: 0, infantry: 0, archer: 0, cavalry: 0 };
      return p._armyByType;
    }

    function deductArmyByType(playerIndex, selected) {
      const p = players[playerIndex];
      const buckets = ensureArmyBuckets(p);
      for (const k of Object.keys(buckets)) {
        const want = selected[k] || 0;
        buckets[k] = Math.max(0, (buckets[k] || 0) - want);
      }
    }

    function sendTroops(fromX, fromY, toX, toY, durationSeconds = null, options = {}) {
      const { onArrival = null, payload = null, ownerIndex = 0 } = options;
      const isLocalPlayer = fromX === localPlayerPos.x && fromY === localPlayerPos.y;

      const dx = toX - fromX;
      const dy = toY - fromY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const fullDistance = Math.sqrt(100 * 100 + 100 * 100);
      const travelDuration = (durationSeconds ?? (distance / fullDistance) * 60) / Math.max(1, gameSpeed); // seconds, scaled by speed
      const travelMillis = travelDuration * 1000;

      // Visual icon for everyone
      const icon = document.createElement('img');
      icon.src = 'army-icon.png';
      icon.className = 'army-icon bubble';
      icon.style.left = `${fromX}%`;
      icon.style.top = `${fromY}%`;
      const color = playerColors[ownerIndex % playerColors.length] || '#fff';
      icon.style.borderColor = color;
      game.appendChild(icon);

      // Draw movement line only for local player
      let line = null;
      if (isLocalPlayer) {
        line = document.createElement('div');
        line.style.position = 'absolute';
        line.style.left = '0';
        line.style.top = '0';
        line.style.width = '100%';
        line.style.height = '100%';
        line.style.pointerEvents = 'none';
        const svgNS = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNS, 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.style.position = 'absolute';
        svg.style.left = '0';
        svg.style.top = '0';
        const linePath = document.createElementNS(svgNS, 'line');
        linePath.setAttribute('x1', `${fromX}%`);
        linePath.setAttribute('y1', `${fromY}%`);
        linePath.setAttribute('x2', `${toX}%`);
        linePath.setAttribute('y2', `${toY}%`);
        linePath.setAttribute('stroke', color);
        linePath.setAttribute('stroke-width', '2');
        svg.appendChild(linePath);
        line.appendChild(svg);
        game.appendChild(line);
      }

      const startTime = performance.now();
      function animate(time) {
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / travelMillis, 1);
        const currentX = fromX + dx * progress;
        const currentY = fromY + dy * progress;
        icon.style.left = `${currentX}%`;
        icon.style.top = `${currentY}%`;
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          if (icon.parentNode === game) game.removeChild(icon);
          if (line && line.parentNode === game) game.removeChild(line);
          if (typeof onArrival === 'function') {
            onArrival(payload);
          } else {
            const key = `${Math.round(toX)},${Math.round(toY)}`;
            if (farmsMap.has(key)) {
              const rec = farmOwners.get(key) || { ownerIndex, ownerLabel: `Player ${ownerIndex + 1}`, troops: 0 };
              farmOwners.set(key, rec);
              updateFarmVisual(key);
            }
          }
        }
      }
      requestAnimationFrame(animate);
    }
    function updateCastleVisual(key) {
      const el = castleElements.get(key);
      if (!el) return;
      const span = el.querySelector('span');
      // deduce owner index from key (each castle belongs to a fixed player by position)
      const [x, y] = key.split(',').map(Number);
      const ownerIndex = positions.findIndex(([px, py]) => px === x && py === y);
      const color = playerColors[ownerIndex % playerColors.length] || '#fff';
      el.classList.add('owned');
      el.style.outlineColor = color;
      const troops = players[ownerIndex] ? (players[ownerIndex].army || 0) : 0;
      if (span) span.textContent = `Player ${ownerIndex + 1} — Garrison: ${troops}`;
    }

    function hire(type, cost) {
      const maxBuy = Math.floor(gold / cost);
      if (maxBuy < 1) {
        createInfoPopup("Not enough gold!");
        return;
      }

      createInputPopup(`How many ${type}s do you want to hire?`, maxBuy, (count) => {
        const total = count * cost;
        gold -= total; players[0].gold = gold;
        army += count; players[0].army = army;
        goldText.textContent = Math.floor(gold);
        armyText.textContent = army;
        syncCastleGarrison(0);
        createInfoPopup(`Hired ${count} ${type}(s)!`);
      });
    }

    function addObject(type, x, y, label, onClick) {
      const div = document.createElement("div");
      div.className = `object ${type}`;
      div.style.left = `${x}%`;
      div.style.top = `${y}%`;
      div.dataset.x = x;
      div.dataset.y = y;

      const img = document.createElement("img");
      img.src = type === "castle" ? "castle.png" : type === "center" ? "center_castle.png" : "mine.png";
      img.style.width = type === "center" ? "72px" : type === "mine" ? "48px" : "64px";
      div.appendChild(img);

      if (label) {
        const span = document.createElement("span");
        span.textContent = label;
        div.appendChild(span);
      }

      div.onclick = onClick;
      game.appendChild(div);
      return div;
    }

    // Set local player position from first castle (Player 1)
    let localPlayerPos = { x: positions[0][0], y: positions[0][1] };

    // Center castle — capturable; owner gets +200/min
    centerElement = addObject("center", 50, 50, "Central Castle — Guard: " + centerDefenseMax, () => {
      if (army > 0) {
        const b = ensureArmyBuckets(players[0]);
        createTroopPopup(["infantry", "archer", "cavalry", "militia"], {
          infantry: b.infantry || 0,
          archer: b.archer || 0,
          cavalry: b.cavalry || 0,
          militia: b.militia || 0
        }, (selectedTroops, totalSent) => {
          army -= totalSent; players[0].army = army; armyText.textContent = army;
          deductArmyByType(0, selectedTroops);
          syncCastleGarrison(0);
          const time = Math.floor(Math.random() * 5) + 3;
          sendTroops(localPlayerPos.x, localPlayerPos.y, 50, 50, time, {
            ownerIndex: 0,
            payload: { sent: totalSent, attackerIndex: 0 },
            onArrival: (p) => {
              if (centralOwnerIndex === null) {
                // fight neutral defenders and grant per-1% rewards
                const before = centerDefense;
                const { attLeft, defLeft } = resolveBattle(p.sent, before);
                centerDefense = defLeft;
                grantCenterGuardReward(p.attackerIndex, before, centerDefense);
                if (attLeft > 0 && defLeft === 0) {
                  centralOwnerIndex = p.attackerIndex;
                  centralGarrison = attLeft; // survivors stay as central garrison
                  // Award dynamic pool to the captor
                  if (centerRewardPool > 0) {
                    const award = Math.floor(centerRewardPool);
                    players[p.attackerIndex].gold += award;
                    if (p.attackerIndex === 0) {
                      gold = players[0].gold; goldText.textContent = Math.floor(gold);
                      showToast(`+${award} gold (center pool)`);
                    }
                    centerRewardPool = 0;
                    updateCenterVisual();
                  }
                }
              } else if (centralOwnerIndex === p.attackerIndex) {
                // reinforce own center
                centralGarrison += p.sent;
              } else {
                // fight current owner's garrison
                const { attLeft, defLeft } = resolveBattle(p.sent, centralGarrison);
                if (attLeft > 0 && defLeft === 0) {
                  centralOwnerIndex = p.attackerIndex;
                  centralGarrison = attLeft;
                  // Award dynamic pool to the captor
                  if (centerRewardPool > 0) {
                    const award = Math.floor(centerRewardPool);
                    players[p.attackerIndex].gold += award;
                    if (p.attackerIndex === 0) {
                      gold = players[0].gold; goldText.textContent = Math.floor(gold);
                      showToast(`+${award} gold (center pool)`);
                    }
                    centerRewardPool = 0;
                    updateCenterVisual();
                  }
                } else {
                  centralGarrison = defLeft;
                }
              }
              updateCenterVisual();
            }
          });
          createInfoPopup(`Marching to Central Castle. Arrival in ${time} seconds.`);
        });
      } else {
        createInfoPopup("No troops available!");
      }
    });

    positions.forEach(([x, y], index) => {
      const isLocal = index === 0;
      const label = `Player ${index + 1}`;
      const onClick = () => {
        if (isLocal) {
          const garrisonNow = players[0].army || 0;
          createInfoPopup(`Your castle garrison: ${garrisonNow}`);
        } else {
          // Attack enemy castle
          if (army > 0) {
            const b = ensureArmyBuckets(players[0]);
            createTroopPopup(["infantry", "archer", "cavalry", "militia"], {
              infantry: b.infantry || 0,
              archer: b.archer || 0,
              cavalry: b.cavalry || 0,
              militia: b.militia || 0
            }, (selectedTroops, totalSent) => {
              army -= totalSent; players[0].army = army; armyText.textContent = army;
              deductArmyByType(0, selectedTroops);
              syncCastleGarrison(0);
              const time = Math.floor(Math.random() * 5) + 3;
              const key = `${x},${y}`;
              sendTroops(localPlayerPos.x, localPlayerPos.y, x, y, time, {
                ownerIndex: 0,
                payload: { key, defenderIndex: index, sent: totalSent, attackerIndex: 0, originX: localPlayerPos.x, originY: localPlayerPos.y, targetX: x, targetY: y },
                onArrival: (p) => {
                  const defenderArmy = players[p.defenderIndex].army || 0;
                  const { attLeft, defLeft } = resolveBattle(p.sent, defenderArmy);
                  players[p.defenderIndex].army = defLeft;
                  syncCastleGarrison(p.defenderIndex);
                  if (attLeft > 0 && defLeft === 0) {
                    const victim = players[p.defenderIndex];
                    const loot = calcRandomLoot(victim.gold);
                    victim.gold = Math.max(0, victim.gold - loot);
                    players[0].gold += loot; gold = players[0].gold; goldText.textContent = Math.floor(gold);
                    showToast(`Looted +${loot} gold`);
                    createInfoPopup(`Raid successful! Looted ${loot} gold from ${victim.label}.`);
                    // send survivors back to our castle with visible movement
                    sendBackSurvivors(p.targetX, p.targetY, p.originX, p.originY, attLeft, p.attackerIndex);
                  } else if (defLeft > 0) {
                    createInfoPopup(`Raid repelled! Defender left: ${defLeft}.`);
                  } else {
                    createInfoPopup(`Both forces annihilated.`);
                  }
                }
              });
              createInfoPopup(`Attacking ${label}. Arrival in ${time} seconds.`);
            });
          } else {
            createInfoPopup("No troops available!");
          }
        }
      };
      const div = addObject("castle", x, y, label, onClick);
      const ckey = `${x},${y}`;
      castleElements.set(ckey, div);
      const color = playerColors[index % playerColors.length] || '#fff';
      div.classList.add('owned');
      div.style.outlineColor = color;
      // set initial garrison label
      const rec = castleGarrisons.get(ckey);
      const span = div.querySelector('span');
      if (span) span.innerHTML = `${label} — Garrison: <img src="army-icon.png" class="army-glyph">${rec ? rec.troops : 0}`;
      if (isLocal) {
        div.classList.add("local-player");
      }
    });

    for (let i = 0; i < players.length; i++) syncCastleGarrison(i);
    positions.forEach(([x, y]) => updateCastleVisual(`${x},${y}`));
    updateCenterVisual();

    // Farms (random generation)
    const farms = [];
    const minX = 10, maxX = 90;
    const minY = 10, maxY = SAFE_MAX_Y - 2; // keep farms above the HUD
    while (farms.length < 24) {
      const x = Math.floor(Math.random() * (maxX - minX)) + minX;
      const y = Math.floor(Math.random() * (maxY - minY)) + minY;
      farms.push([x, y]);
    }
    farms.forEach(([x, y]) => {
      const key = `${x},${y}`;
      farmsMap.set(key, true);
      const el = addObject('mine', x, y, 'Farm', () => {
        const owner = farmOwners.get(key);
        const isOurs = owner && owner.ownerIndex === 0;
        if (isOurs && owner.troops > 0) {
          // Recall interface
          createInputPopup(`Recall from your farm (max ${owner.troops})`, owner.troops, (count) => {
            // send back to local castle
            owner.troops -= count;
            farmOwners.set(key, owner);
            updateFarmVisual(key);
            const time = Math.floor(Math.random() * 5) + 3;
                sendTroops(x, y, localPlayerPos.x, localPlayerPos.y, time, {
                  ownerIndex: 0,
                  onArrival: () => {
                    // Move recalled troops into available army and sync castle UI
                    players[0].army = (players[0].army || 0) + count;
                    ensureArmyBuckets(players[0]);
                    players[0]._armyByType.militia += count;
                    army += count;
                    armyText.textContent = army;
                    syncCastleGarrison(0);
                    showToast(`Recalled +${count} troops`);
                  }
                });
          });
          return;
        }
        // Otherwise behave as attack/send as before
        if (army > 0) {
          const b = ensureArmyBuckets(players[0]);
          createTroopPopup(['infantry', 'archer', 'cavalry', 'militia'], {
            infantry: b.infantry || 0,
            archer: b.archer || 0,
            cavalry: b.cavalry || 0,
            militia: b.militia || 0
          }, (selectedTroops, totalSent) => {
            army -= totalSent;
            armyText.textContent = army;
            players[0].army = army;
            deductArmyByType(0, selectedTroops);
            syncCastleGarrison(0);
            const time = Math.floor(Math.random() * 5) + 3;
            const ownerIndex = 0; // local player
            const ownerLabel = 'Player 1';
            sendTroops(localPlayerPos.x, localPlayerPos.y, x, y, time, {
              ownerIndex,
              payload: { key, ownerIndex, ownerLabel, troops: totalSent },
              onArrival: (p) => {
                const existing = farmOwners.get(p.key);
                if (existing && existing.ownerIndex !== p.ownerIndex) {
                  // Battle on the farm
                  const { attLeft, defLeft } = resolveBattle(p.troops, existing.troops);
                  if (attLeft > 0) {
                    farmOwners.set(p.key, { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: attLeft });
                  } else {
                    farmOwners.set(p.key, { ownerIndex: existing.ownerIndex, ownerLabel: existing.ownerLabel, troops: defLeft });
                  }
                } else {
                  const rec = existing || { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: 0 };
                  rec.ownerIndex = p.ownerIndex; rec.ownerLabel = p.ownerLabel; rec.troops += p.troops;
                  farmOwners.set(p.key, rec);
                }
                updateFarmVisual(p.key);
                const lf = countFarmsOwned(0);
                farmsText.textContent = lf;
                {
                  const gross = 60 + lf * 30 + (centralOwnerIndex === 0 ? 200 : 0);
                  const expense = estimateAutoHireCostPerMin(players[0]);
                  const net = Math.max(0, Math.floor(gross - expense));
                  incomeText.textContent = net;
                }
              }
            });
            createInfoPopup(`Sending troops to farm. Arrival in ${time} seconds.`);
          });
        } else {
          createInfoPopup('No troops available!');
        }
      });
      el.dataset.key = key;
      farmElements.set(key, el);
    });

    // --- AI Farm Recall Helpers ---
    function parseKeyToXY(key) {
      const [sx, sy] = key.split(',');
      return [Number(sx), Number(sy)];
    }

    // Recall troops from up to maxFarms AI-owned farms that have at least `threshold` troops.
    // Returns total number of troops recalled (sum across farms).
    function aiRecallFromFarms(ai, threshold = 10, maxFarms = 2) {
      const owned = [];
      farmOwners.forEach((rec, key) => {
        if (rec.ownerIndex === ai.index && (rec.troops || 0) >= threshold) {
          owned.push({ key, troops: rec.troops });
        }
      });
      if (owned.length === 0) return 0;
      // Recall from the largest farms first
      owned.sort((a, b) => b.troops - a.troops);
      const chosen = owned.slice(0, maxFarms);
      let total = 0;
      chosen.forEach(({ key, troops }) => {
        const count = troops; // recall all from that farm
        const rec = farmOwners.get(key);
        if (!rec || rec.troops < count) return;
        rec.troops -= count;
        farmOwners.set(key, rec);
        updateFarmVisual(key);
        const [fx, fy] = parseKeyToXY(key);
        // animate recall back to AI's castle
        sendTroops(fx, fy, ai.x, ai.y, null, {
          ownerIndex: ai.index,
          onArrival: () => {
            players[ai.index].army = (players[ai.index].army || 0) + count;
            ensureArmyBuckets(players[ai.index]);
            players[ai.index]._armyByType.militia += count; // attribute as militia for upkeep
            syncCastleGarrison(ai.index);
          }
        });
        total += count;
      });
      return total;
    }

    // --- Smarter AI Planning Helpers ---
    function distSq(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; }

    function getRichOpponent(ai) {
      let bestIdx = -1;
      let bestGold = -1;
      players.forEach((p) => {
        if (p.index === ai.index) return;
        if (p.gold > bestGold) { bestGold = p.gold; bestIdx = p.index; }
      });
      return { index: bestIdx, gold: Math.floor(Math.max(0, bestGold)) };
    }

    function pickBestFarmTarget(ai) {
      // Prefer: neutral farms first; otherwise enemy farms with the fewest defenders.
      const rich = getRichOpponent(ai);
      let best = null;
      farmsMap.forEach((_, key) => {
        const rec = farmOwners.get(key) || null;
        const [fx, fy] = key.split(',').map(Number);
        if (!rec) {
          // neutral farm
          const score = 120000 - distSq(ai.x, ai.y, fx, fy) * 0.5; // higher priority + softer distance penalty
          if (!best || score > best.score) best = { type: 'neutral-farm', key, fx, fy, def: 0, score };
        } else if (rec.ownerIndex !== ai.index) {
          const def = rec.troops || 0;
          const richBonus = (rich.index === rec.ownerIndex && rich.gold >= RICH_GOLD_THRESHOLD) ? 20000 : 0;
          const score = 50000 - def*5000 - distSq(ai.x, ai.y, fx, fy) * 0.5 + richBonus; // harass rich opponents' farms
          if (!best || score > best.score) best = { type: 'enemy-farm', key, fx, fy, def, score };
        }
      });
      return best; // {key, fx, fy, def}
    }

    function pickBestCastleRaid(ai) {
      // Weighted roulette by current gold among opponents; probability ~ gold / sum(gold)
      const pool = [];
      let sum = 0;
      players.forEach((p) => {
        if (p.index === ai.index) return;
        const w = Math.max(0, Math.floor(p.gold));
        if (w > 0) { pool.push(p.index); sum += w; }
      });
      if (pool.length === 0) return null;
      let pick = pool[0];
      if (sum > 0) {
        let r = Math.random() * sum;
        for (const idx of pool) {
          const w = Math.max(0, Math.floor(players[idx].gold));
          if (r < w) { pick = idx; break; }
          r -= w;
        }
      }
      const [cx, cy] = positions[pick];
      const def = players[pick].army || 0;
      // If target is not rich enough, skip raiding — prefer farms/expansion
      if ((players[pick].gold || 0) < RAID_MIN_TARGET_GOLD) return null;
      return { defenderIndex: pick, cx, cy, def };
    }

    function canTakeCenter(ai, sendAmount) {
      if (centralOwnerIndex === null) {
        return sendAmount > centerDefense; // beat neutral guard
      }
      if (centralOwnerIndex === ai.index) return false; // already own
      return sendAmount > centralGarrison; // beat current owner's garrison
    }

    // --- Aggression Helpers: superiority check & sweeping weak farms ---
    function averageOpponentTroops(ai) {
      let sum = 0, n = 0;
      players.forEach((p) => {
        if (p.index === ai.index) return;
        sum += getTotalTroops(p.index);
        n++;
      });
      return n > 0 ? (sum / n) : 0;
    }

    // Try to rapidly capture several weakest farms when we are stronger than average.
    // Returns true if at least one attack was launched.
    function aiAggressiveSweep(ai) {
      const prof = ai.aiProfile || {};
      const keepP = Math.max(0, Math.min(0.95, prof.keepBackMin || 0.2));
      const maxTargets = Math.max(1, prof.sweepMaxTargets || 3);

      // Build candidate list: all farms not ours, with defenders asc, within radius
      const candidates = [];
      const maxD2 = SWEEP_MAX_RADIUS * SWEEP_MAX_RADIUS;
      farmsMap.forEach((_, key) => {
        const rec = farmOwners.get(key) || null;
        const [fx, fy] = parseKeyToXY(key);
        const d2 = distSq(ai.x, ai.y, fx, fy);
        if (d2 > maxD2) return; // skip far targets during sweep
        if (!rec) {
          // neutral farm: def = 0
          candidates.push({ key, fx, fy, def: 0, ownerIndex: null });
        } else if (rec.ownerIndex !== ai.index) {
          candidates.push({ key, fx, fy, def: rec.troops || 0, ownerIndex: rec.ownerIndex });
        }
      });
      if (candidates.length === 0) return false;

      // Sort by defenders asc, then by distance asc
      candidates.sort((a, b) => {
        if (a.def !== b.def) return a.def - b.def;
        const da = distSq(ai.x, ai.y, a.fx, a.fy);
        const db = distSq(ai.x, ai.y, b.fx, b.fy);
        return da - db;
      });

      let launched = 0;
      for (const target of candidates.slice(0, maxTargets)) {
        const keep = Math.floor(ai.army * keepP);
        const cap = Math.max(0, ai.army - keep);
        const need = Math.max(1, Math.min(cap, (target.def || 0) + 1));
        if (need <= 0) continue;
        if (cap < need) continue; // not enough without breaking keep-back

        // Deduct from AI garrison
        ai.army -= need;
        ensureArmyBuckets(ai);
        const take = Math.min(need, ai._armyByType.militia || 0);
        ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
        syncCastleGarrison(ai.index);

        // Launch to farm
        sendTroops(ai.x, ai.y, target.fx, target.fy, null, {
          ownerIndex: ai.index,
          payload: { key: target.key, ownerIndex: ai.index, ownerLabel: ai.label, troops: need },
          onArrival: (p) => {
            const existing = farmOwners.get(p.key);
            if (existing && existing.ownerIndex !== p.ownerIndex) {
              const { attLeft, defLeft } = resolveBattle(p.troops, existing.troops);
              if (attLeft > 0) {
                farmOwners.set(p.key, { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: attLeft });
              } else {
                farmOwners.set(p.key, { ownerIndex: existing.ownerIndex, ownerLabel: existing.ownerLabel, troops: defLeft });
              }
            } else {
              const rec = existing || { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: 0 };
              rec.ownerIndex = p.ownerIndex; rec.ownerLabel = p.ownerLabel; rec.troops += p.troops;
              farmOwners.set(p.key, rec);
            }
            updateFarmVisual(p.key);
          }
        });
        launched++;
        if (ai.army <= 0) break;
      }
      return launched > 0;
    }

    // --- Value/Difficulty Scoring Helpers ---
    function travelPenalty(ax, ay, bx, by) {
      const d = Math.hypot(ax - bx, ay - by); // 0..~141 on 0..100 grid
      return d * 3; // softer distance penalty -> чаще выбираем фермы
    }

    function scoreCenter(ai, send) {
      const timeLeftMin = Math.max(0, matchTimeLeft / 60);
      const penalty = travelPenalty(ai.x, ai.y, 50, 50) * 0.4; // center: distance matters even less
      let score = -Infinity;

      if (centralOwnerIndex === null) {
        // Neutral: only consider center if we can cross at least one full 1% threshold this push
        const pctPerStep = centerDefenseMax / 100;
        if (send < pctPerStep) return -Infinity;
        // We can earn pool by dealing damage in 1% steps, even if we don't capture
        const dmg = Math.min(send, centerDefense);
        const steps = Math.floor(dmg / pctPerStep); // whole percents we likely cross

        // Expected award from pool slices: each step pays ~1% of *current* pool.
        // We discount by 0.7 to be conservative (pool shrinks as we take multiple steps in one strike).
        const expectedPoolAward = Math.floor((centerRewardPool * 0.01) * steps * 0.7);

        // Additional fixed reward per step from design (kept for tactical incentive)
        const fixedPerStep = CENTER_REWARD_PER_PERCENT;
        const fixedReward = steps * fixedPerStep;

        // Low-guard bonus to finish
        let bonus = 0;
        if (centerDefense < 600) bonus += 400;
        if (centerDefense < 300) bonus += 900;

        // If the pool is large, strongly prefer center
        const poolBoost = Math.min(2000, Math.floor(centerRewardPool * 0.15));

        // If we can capture on this push, also add the remaining pool
        const capturePool = (send > centerDefense ? Math.floor(centerRewardPool) : 0);

        // Expected future income if we likely capture soon: 200/min over remaining time, weighted by capture likelihood
        const captureLikelihood = Math.min(1, send / Math.max(1, centerDefense));
        const incomeFuture = Math.floor(200 * timeLeftMin * captureLikelihood * 0.8);
        score = expectedPoolAward + fixedReward + bonus + poolBoost + capturePool + incomeFuture - penalty;
      } else if (centralOwnerIndex !== ai.index) {
        // Center owned by someone: only consider if we can breach at least 1% of defense
        const pctPerStep = centerDefenseMax / 100;
        if (send < pctPerStep) return -Infinity;

        // Score similar to a high-income farm, but add center's flat +200/min to owner income
        const owner = players[centralOwnerIndex];
        // Use the income as if the owner is earning +200/min from the center
        // Use playerIncomes if available, else estimate (farms owned * 10 + 30 + 200)
        let ownerIncome = 0;
        if (typeof playerIncomes !== 'undefined' && playerIncomes[centralOwnerIndex] !== undefined) {
          ownerIncome = playerIncomes[centralOwnerIndex] + 200; // assume playerIncomes already reflects 60/30 baseline
        } else {
          // Estimate gross income with 60 base and +30 per farm, plus +200 for owning center
          const farmsOwned = countFarmsOwned(centralOwnerIndex);
          ownerIncome = 60 + farmsOwned * 30 + 200;
        }
        const ownerGold = owner.gold || 0;
        const potential = ownerIncome * 5 + ownerGold; // arbitrary scaling
        score += potential;
        // Deny the owner's +200/min going forward as an additional incentive
        const denyIncome = Math.floor(200 * timeLeftMin * 0.6);
        score += denyIncome;
        score -= penalty;
      }

      // Endgame push: last 3 minutes → center becomes even more desirable
      if (matchTimeLeft <= 180 && score > -Infinity) score *= 1.5;
      return score;
    }

    function scoreFarm(ai, farmTarget, send) {
      const timeLeftMin = Math.max(0, matchTimeLeft / 60);
      const penalty = travelPenalty(ai.x, ai.y, farmTarget.fx, farmTarget.fy);
      const def = farmTarget.def || 0;
      if (send <= def) return -Infinity; // cannot win
      // Income gain: +30/min for the remaining time if we flip or capture
      const incomeGain = 30 * timeLeftMin;
      // Neutral farms are even more attractive (stronger than before)
      const neutralBonus = (farmTarget.type === 'neutral-farm') ? 150 : 0;
      // Softness bonus: the fewer defenders, the more attractive (0..180)
      const softness = Math.max(0, 6 - def) * 30;
      // Prefer farms a bit more by reducing travel penalty weight
      return incomeGain + neutralBonus + softness - (penalty * 0.7);
    }

    // Decide how many actions a bot can do in one tick (multi-action)
    function computeAIMaxActions(ai) {
      // Base 1 action; grant extra for having sizable army and spare gold
      let acts = 1;
      if ((ai.army || 0) >= 8) acts += 1;       // medium stack
      if ((ai.army || 0) >= 20) acts += 1;      // large stack
      if ((ai.gold  || 0) >= 300) acts += 1;    // spare gold for re-buys
      // Cap by profile (defaults to 2)
      const cap = (ai.aiProfile && ai.aiProfile.multiActCap) ? ai.aiProfile.multiActCap : 2;
      return Math.min(acts, cap);
    }

    // --- Simple AI ---
    function aiHireAndAct(ai) {
      // 1) Consolidate sometimes (pull back from farms) — per profile
      const prof = ai.aiProfile || { recallChance: 0.25, recallThreshold: 8, recallMaxFarms: 2 };
      if (Math.random() < prof.recallChance) {
        const recalled = aiRecallFromFarms(ai, prof.recallThreshold, prof.recallMaxFarms);
        if (recalled > 0) return; // wait for troops to come back this cycle
      }

      // 2) Buy militia if possible (keeps AI active)
      const militiaCost = 30;
      const canBuy = Math.floor(ai.gold / militiaCost);
      if (canBuy > 0) {
        const toBuy = Math.min(canBuy, 5 + Math.floor(Math.random() * 10));
        ai.gold -= toBuy * militiaCost;
        ai.army += toBuy;
        ensureArmyBuckets(ai);
        ai._armyByType.militia += toBuy;
      }

      // Superiority trigger: if our army is larger than the average opponent garrison, sweep weakest farms
      const avgOpp = averageOpponentTroops(ai);
      const superior = ai.army >= Math.max(6, Math.ceil(avgOpp * 1.15)); // 15%+ above average
      if (superior) {
        aiAggressiveSweep(ai); // launch quick captures if available, then continue with remaining actions
      }

      // Multi-action core: attempt up to N actions this tick
      function attemptOneAction() {
        // 3) Decide send fraction based on time pressure — per profile
        const urgent = (matchTimeLeft <= 120); // last 2 minutes
        const baseFrac = prof.sendFracMin + Math.random() * (prof.sendFracMax - prof.sendFracMin);
        const frac = urgent ? Math.min(0.9, baseFrac * prof.urgentBoost) : baseFrac;
        let send = Math.max(1, Math.floor(ai.army * frac));
        if (send <= 0) return false;

        // Percent-based send override (per profile): sometimes pick a random % of current garrison
        if (Math.random() < (prof.percentDecisionChance || 0)) {
          const minP = Math.max(0.01, Math.min(0.99, prof.sendPercentMin || 0.01));
          const maxP = Math.max(minP, Math.min(0.99, prof.sendPercentMax || 0.50));
          const keepP = Math.max(0, Math.min(0.95, prof.keepBackMin || 0));
          const pct = minP + Math.random() * (maxP - minP);
          const keep = Math.floor(ai.army * keepP);
          const desired = Math.max(1, Math.floor(ai.army * pct));
          const cap = Math.max(0, ai.army - keep);
          const finalSend = Math.min(desired, cap);
          if (finalSend >= 1) {
            send = finalSend; // use the percent-based decision for this action
          } else {
            return false; // too small due to keep-back
          }
        }

        // 4) Priorities by expected value vs difficulty
        const farmTarget = pickBestFarmTarget(ai);
        let farmDecision = { score: -Infinity, amount: 0 };
        if (farmTarget && ai.army > farmTarget.def) {
          const need = Math.min(ai.army, Math.max(1, farmTarget.def + 1));
          const sendFarm = Math.max(1, Math.min(send, need));
          const s = scoreFarm(ai, farmTarget, sendFarm) * (prof.farmBias || 1);
          farmDecision = { score: s, amount: sendFarm };
        }

        const centerScore = scoreCenter(ai, send) * (prof.centerAggression || 1);

        // Choose higher score among center and farm; center must beat farm by 5% to take priority
        let preferCenter = (centerScore > 0) && (centerScore >= farmDecision.score * 1.05);

        // Probabilistic override: if we can cross at least 1% this push, allow center with high chance even if farm is slightly better
        const pctPerStep = centerDefenseMax / 100;
        const canOnePercent = (centralOwnerIndex === null)
          ? (send >= pctPerStep)
          : (centralOwnerIndex !== ai.index && send >= pctPerStep);
        const pushChance = (ai.aiProfile && typeof ai.aiProfile.centerPushChance === 'number')
          ? ai.aiProfile.centerPushChance
          : CENTER_ONEPUSH_CHANCE;

        if (!preferCenter && centerScore > 0 && canOnePercent) {
          // If center is within 30% of farm score, roll the dice to push center
          const within = centerScore >= farmDecision.score * 0.70;
          if (within && Math.random() < pushChance) {
            preferCenter = true;
          }
        }

        if (preferCenter) {
          // If we are short for capture (vs guard/garrison), try a quick rally (recall) and wait a cycle
          const needForNeutral = Math.max(0, centerDefense + 1);
          const needForOwned   = Math.max(0, centralGarrison + 1);
          const need = (centralOwnerIndex === null) ? needForNeutral : (centralOwnerIndex === ai.index ? 0 : needForOwned);
          if (need > 0 && send < need) {
            const recalledNow = aiRecallFromFarms(ai, prof.recallThreshold || 8, Math.max(1, prof.recallMaxFarms || 2));
            if (recalledNow > 0) return true; // we "did" an action: rallied; end this attempt
          }

          // Attack center with `send`
          ai.army -= send;
          if (ai._armyByType) {
            const take = Math.min(send, ai._armyByType.militia || 0);
            ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
          }
          syncCastleGarrison(ai.index);
          sendTroops(ai.x, ai.y, 50, 50, null, {
            ownerIndex: ai.index,
            payload: { sent: send, attackerIndex: ai.index },
            onArrival: (p) => {
              if (centralOwnerIndex === null) {
                const before = centerDefense;
                const { attLeft, defLeft } = resolveBattle(p.sent, before);
                centerDefense = defLeft;
                grantCenterGuardReward(p.attackerIndex, before, centerDefense);
                if (attLeft > 0 && defLeft === 0) {
                  centralOwnerIndex = p.attackerIndex; centralGarrison = attLeft;
                  if (centerRewardPool > 0) {
                    const award = Math.floor(centerRewardPool);
                    players[p.attackerIndex].gold += award;
                    centerRewardPool = 0;
                    updateCenterVisual();
                  }
                }
              } else if (centralOwnerIndex === p.attackerIndex) {
                centralGarrison += p.sent;
              } else {
                const { attLeft, defLeft } = resolveBattle(p.sent, centralGarrison);
                if (attLeft > 0 && defLeft === 0) {
                  centralOwnerIndex = p.attackerIndex; centralGarrison = attLeft;
                  if (centerRewardPool > 0) {
                    const award = Math.floor(centerRewardPool);
                    players[p.attackerIndex].gold += award;
                    centerRewardPool = 0;
                    updateCenterVisual();
                  }
                } else {
                  centralGarrison = defLeft;
                }
              }
              updateCenterVisual();
            }
          });
          return true;
        }

        if (farmDecision.score > 0) {
          const sendFarm = farmDecision.amount;
          ai.army -= sendFarm;
          if (ai._armyByType) {
            const take = Math.min(sendFarm, ai._armyByType.militia || 0);
            ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
          }
          syncCastleGarrison(ai.index);
          sendTroops(ai.x, ai.y, farmTarget.fx, farmTarget.fy, null, {
            ownerIndex: ai.index,
            payload: { key: farmTarget.key, ownerIndex: ai.index, ownerLabel: ai.label, troops: sendFarm },
            onArrival: (p) => {
              const existing = farmOwners.get(p.key);
              if (existing && existing.ownerIndex !== p.ownerIndex) {
                const { attLeft, defLeft } = resolveBattle(p.troops, existing.troops);
                if (attLeft > 0) {
                  farmOwners.set(p.key, { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: attLeft });
                } else {
                  farmOwners.set(p.key, { ownerIndex: existing.ownerIndex, ownerLabel: existing.ownerLabel, troops: defLeft });
                }
              } else {
                const rec = existing || { ownerIndex: p.ownerIndex, ownerLabel: p.ownerLabel, troops: 0 };
                rec.ownerIndex = p.ownerIndex; rec.ownerLabel = p.ownerLabel; rec.troops += p.troops;
                farmOwners.set(p.key, rec);
              }
              updateFarmVisual(p.key);
            }
          });
          return true;
        }

        //    c) If farm not possible, try a castle raid vs rich & weak
        const raid = pickBestCastleRaid(ai);
        if (raid && ai.army > raid.def) {
          const needRaid = Math.min(ai.army, Math.max(1, raid.def + 1));
          const sendRaid = Math.max(1, Math.min(send, needRaid));
          ai.army -= sendRaid;
          if (ai._armyByType) {
            const take = Math.min(sendRaid, ai._armyByType.militia || 0);
            ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
          }
          syncCastleGarrison(ai.index);
          sendTroops(ai.x, ai.y, raid.cx, raid.cy, null, {
            ownerIndex: ai.index,
            payload: { key: `${raid.cx},${raid.cy}`, defenderIndex: raid.defenderIndex, sent: sendRaid, attackerIndex: ai.index, originX: ai.x, originY: ai.y, targetX: raid.cx, targetY: raid.cy },
            onArrival: (p) => {
              const defenderArmy = players[p.defenderIndex].army || 0;
              const { attLeft, defLeft } = resolveBattle(p.sent, defenderArmy);
              players[p.defenderIndex].army = defLeft;
              syncCastleGarrison(p.defenderIndex);
              if (attLeft > 0 && defLeft === 0) {
                const victim = players[p.defenderIndex];
                const loot = calcRandomLoot(victim.gold);
                victim.gold = Math.max(0, victim.gold - loot);
                players[ai.index].gold += loot;
                sendBackSurvivors(p.targetX, p.targetY, p.originX, p.originY, attLeft, ai.index);
              }
            }
          });
          return true;
        }

        //    d) If none viable, and we can make a serious push on center (even if not urgent), try it
        if (canTakeCenter(ai, send)) {
          ai.army -= send;
          if (ai._armyByType) {
            const take = Math.min(send, ai._armyByType.militia || 0);
            ai._armyByType.militia = Math.max(0, (ai._armyByType.militia || 0) - take);
          }
          syncCastleGarrison(ai.index);
          sendTroops(ai.x, ai.y, 50, 50, null, {
            ownerIndex: ai.index,
            payload: { sent: send, attackerIndex: ai.index },
            onArrival: (p) => {
              if (centralOwnerIndex === null) {
                const before = centerDefense;
                const { attLeft, defLeft } = resolveBattle(p.sent, before);
                centerDefense = defLeft;
                grantCenterGuardReward(p.attackerIndex, before, centerDefense);
                if (attLeft > 0 && defLeft === 0) {
                  centralOwnerIndex = p.attackerIndex; centralGarrison = attLeft;
                  if (centerRewardPool > 0) {
                    const award = Math.floor(centerRewardPool);
                    players[p.attackerIndex].gold += award;
                    centerRewardPool = 0;
                    updateCenterVisual();
                  }
                }
              } else if (centralOwnerIndex === p.attackerIndex) {
                centralGarrison += p.sent;
              } else {
                const { attLeft, defLeft } = resolveBattle(p.sent, centralGarrison);
                if (attLeft > 0 && defLeft === 0) {
                  centralOwnerIndex = p.attackerIndex; centralGarrison = attLeft;
                  if (centerRewardPool > 0) {
                    const award = Math.floor(centerRewardPool);
                    players[p.attackerIndex].gold += award;
                    centerRewardPool = 0;
                    updateCenterVisual();
                  }
                }
                else { centralGarrison = defLeft; }
              }
              updateCenterVisual();
            }
          });
          return true;
        }

        //    e) Otherwise, hold — let income/auto-hire stack for a stronger push next cycle
        return false;
      }

      const maxActs = computeAIMaxActions(ai);
      for (let step = 0; step < maxActs; step++) {
        const did = attemptOneAction();
        if (!did) break; // stop if no viable action this sub-step
      }
    }

    // Run AI for players 2..8 with jittered schedule (per profile)
    function scheduleAI(ai) {
      const prof = ai.aiProfile || { actionDelayMin: 6000, actionDelayMax: 12000 };
      const span = Math.max(0, (prof.actionDelayMax - prof.actionDelayMin));
      const baseDelay = (prof.actionDelayMin || 6000) + Math.random() * span;
      const delay = Math.max(100, baseDelay / Math.max(1, gameSpeed)); // faster ticks at higher speed
      if (ai._aiTimerId) { clearTimeout(ai._aiTimerId); ai._aiTimerId = null; }
      ai._aiTimerId = setTimeout(() => {
        aiHireAndAct(ai);
        scheduleAI(ai); // reschedule with new jitter per profile
      }, delay);
    }
    function cancelAI(ai) {
      if (ai && ai._aiTimerId) { clearTimeout(ai._aiTimerId); ai._aiTimerId = null; }
    }
    for (let i = 1; i < players.length; i++) {
      scheduleAI(players[i]);
    }

    // Ensure initial sidebar render runs once at startup
    renderPlayerSidebar();
  </script>
</body>
</html>
    // --- Local AI control (player 0) ---
    const toggleLocalAIButton = document.getElementById('toggle-local-ai');
    const localAIProfileSelect = document.getElementById('local-ai-profile');
    let localAIEnabled = false;

    // restore saved state
    try {
      const savedLocalAI = localStorage.getItem('localAIEnabled');
      const savedProfile = localStorage.getItem('localAIProfileName');
      if (savedProfile && localAIProfileSelect) localAIProfileSelect.value = savedProfile;
      if (savedLocalAI !== null) localAIEnabled = JSON.parse(savedLocalAI);
    } catch {}

    function refreshLocalAIUI() {
      if (!toggleLocalAIButton) return;
      toggleLocalAIButton.textContent = localAIEnabled ? 'ON' : 'OFF';
      toggleLocalAIButton.classList.remove('on','off');
      toggleLocalAIButton.classList.add(localAIEnabled ? 'on' : 'off');
      toggleLocalAIButton.title = localAIEnabled ? 'Local player is AI-controlled' : 'Local player is human-controlled';
    }
    refreshLocalAIUI();

    function applyLocalAIProfile() {
      const name = localAIProfileSelect ? localAIProfileSelect.value : 'Balanced';
      players[0].aiProfile = createAIProfileByName(name);
      try { localStorage.setItem('localAIProfileName', name); } catch {}
    }

    if (localAIProfileSelect) {
      localAIProfileSelect.onchange = () => {
        applyLocalAIProfile();
        if (localAIEnabled) { cancelAI(players[0]); scheduleAI(players[0]); }
        showToast(`Local AI profile: ${localAIProfileSelect.value}`);
      };
    }

    if (toggleLocalAIButton) {
      toggleLocalAIButton.onclick = () => {
        localAIEnabled = !localAIEnabled;
        try { localStorage.setItem('localAIEnabled', JSON.stringify(localAIEnabled)); } catch {}
        refreshLocalAIUI();
        if (localAIEnabled) {
          applyLocalAIProfile();
          scheduleAI(players[0]);
          showToast('Local AI enabled');
        } else {
          cancelAI(players[0]);
          showToast('Local AI disabled');
        }
      };
    }

    // If enabled from previous session, start immediately
    if (localAIEnabled) { applyLocalAIProfile(); scheduleAI(players[0]); }